<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 阅读 SDWebImage 源码（一） · 一鸣的博客</title><meta name="description" content="阅读 SDWebImage 源码（一） - iYiming"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.jpg"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://iYiming.me/atom.xml" title="一鸣的博客"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.jpg"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/jiajiayouba" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/iYiming" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">阅读 SDWebImage 源码（一）</h1><div class="post-info">2016年4月24日</div><div class="post-content"><p>SDWebImage 是 Objective-C 项目中最常用的异步下载并缓存图片的第三方库。GitHub 地址：</p>
<p><a href="https://github.com/rs/SDWebImage" target="_blank" rel="external">https://github.com/rs/SDWebImage</a></p>
<p>它为我们提供了简单的入口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// #import &quot;UIImageView+WebCache.h&quot;</div><div class="line"></div><div class="line">NSURL *imageURL = [NSURL URLWithString:@&quot;XXX&quot;]; // 图片地址</div><div class="line"></div><div class="line">UIImageView *imageView = [[UIImageView alloc] init];</div><div class="line">[imageView sd_setImageWithURL:imageURL]; // 下载并缓存图片</div><div class="line">[self.view addSubview:imageView];</div></pre></td></tr></table></figure>
<p>SDWebImage 下载缓存机制如下：</p>
<p><img src="/images/SDWebImage_Read/0.png" alt="Sample Flowchart Template.png"></p>
<p>先看看它明确的职责分工：</p>
<p><code>SDImageCache</code> : 负责管理缓存 内存、硬盘<br><code>SDWebImageDownloader</code> : 负责管理下载<br><code>SDWebImageManager</code> : 负责管理上面两者  </p>
<h2 id="SDWebImageManager-干了啥"><a href="#SDWebImageManager-干了啥" class="headerlink" title="SDWebImageManager 干了啥"></a>SDWebImageManager 干了啥</h2><p>上面代码中设置图片视图 URL 后，会调用下面方法：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div></pre></td><td class="code"><pre><div class="line">// SDWebImageManager.m</div><div class="line"></div><div class="line">- (id &lt;SDWebImageOperation&gt;)downloadImageWithURL:(NSURL *)url</div><div class="line">                                         options:(SDWebImageOptions)options</div><div class="line">                                        progress:(SDWebImageDownloaderProgressBlock)progressBlock</div><div class="line">                                       completed:(SDWebImageCompletionWithFinishedBlock)completedBlock &#123;</div><div class="line">    </div><div class="line">    ...</div><div class="line">    </div><div class="line">    __block SDWebImageCombinedOperation *operation = [SDWebImageCombinedOperation new];</div><div class="line">    __weak SDWebImageCombinedOperation *weakOperation = operation;</div><div class="line"></div><div class="line">    ...</div><div class="line">    </div><div class="line">    NSString *key = [self cacheKeyForURL:url];</div><div class="line">    </div><div class="line">    // 0</div><div class="line">    operation.cacheOperation = [self.imageCache queryDiskCacheForKey:key done:^(UIImage *image, SDImageCacheType cacheType) &#123;</div><div class="line">        if (operation.isCancelled) &#123;</div><div class="line">            @synchronized (self.runningOperations) &#123;</div><div class="line">                [self.runningOperations removeObject:operation];</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        if ((!image || options &amp; SDWebImageRefreshCached) &amp;&amp; (![self.delegate respondsToSelector:@selector(imageManager:shouldDownloadImageForURL:)] || [self.delegate imageManager:self shouldDownloadImageForURL:url])) &#123;</div><div class="line">           </div><div class="line">            ...</div><div class="line">            </div><div class="line">            // 1</div><div class="line">            id &lt;SDWebImageOperation&gt; subOperation = [self.imageDownloader downloadImageWithURL:url options:downloaderOptions progress:progressBlock completed:^(UIImage *downloadedImage, NSData *data, NSError *error, BOOL finished) &#123;</div><div class="line">                __strong __typeof(weakOperation) strongOperation = weakOperation;</div><div class="line">                if (!strongOperation || strongOperation.isCancelled) &#123;</div><div class="line">                    </div><div class="line">                    ...</div><div class="line">                    </div><div class="line">                &#125;</div><div class="line">                else if (error) &#123;</div><div class="line">                    </div><div class="line">                   ...</div><div class="line">                    </div><div class="line">                &#125;</div><div class="line">                else &#123;</div><div class="line">                    </div><div class="line">                    ...</div><div class="line">                    </div><div class="line">                    BOOL cacheOnDisk = !(options &amp; SDWebImageCacheMemoryOnly);</div><div class="line">                    </div><div class="line">                    if (options &amp; SDWebImageRefreshCached &amp;&amp; image &amp;&amp; !downloadedImage) &#123;</div><div class="line">                        </div><div class="line">                    &#125; else if (downloadedImage &amp;&amp; (!downloadedImage.images || (options &amp; SDWebImageTransformAnimatedImage)) &amp;&amp; [self.delegate respondsToSelector:@selector(imageManager:transformDownloadedImage:withURL:)]) &#123; // 2</div><div class="line">                        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123;</div><div class="line">                            UIImage *transformedImage = [self.delegate imageManager:self transformDownloadedImage:downloadedImage withURL:url];</div><div class="line">                            </div><div class="line">                            if (transformedImage &amp;&amp; finished) &#123;</div><div class="line">                                BOOL imageWasTransformed = ![transformedImage isEqual:downloadedImage];</div><div class="line">                                [self.imageCache storeImage:transformedImage recalculateFromImage:imageWasTransformed imageData:(imageWasTransformed ? nil : data) forKey:key toDisk:cacheOnDisk];</div><div class="line">                            &#125;</div><div class="line">                            </div><div class="line">                            dispatch_main_sync_safe(^&#123;</div><div class="line">                                if (strongOperation &amp;&amp; !strongOperation.isCancelled) &#123;</div><div class="line">                                    completedBlock(transformedImage, nil, SDImageCacheTypeNone, finished, url);</div><div class="line">                                &#125;</div><div class="line">                            &#125;);</div><div class="line">                        &#125;);</div><div class="line">                    &#125; else &#123; // 2</div><div class="line">                        if (downloadedImage &amp;&amp; finished) &#123;</div><div class="line">                            [self.imageCache storeImage:downloadedImage recalculateFromImage:NO imageData:data forKey:key toDisk:cacheOnDisk];</div><div class="line">                        &#125;</div><div class="line">                        </div><div class="line">                        dispatch_main_sync_safe(^&#123;</div><div class="line">                            if (strongOperation &amp;&amp; !strongOperation.isCancelled) &#123;</div><div class="line">                                completedBlock(downloadedImage, nil, SDImageCacheTypeNone, finished, url);</div><div class="line">                            &#125;</div><div class="line">                        &#125;);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                </div><div class="line">                ...</div><div class="line">            &#125;];</div><div class="line">         </div><div class="line">            ...</div><div class="line">        &#125;</div><div class="line">        else if (image) &#123; // 3</div><div class="line">            dispatch_main_sync_safe(^&#123;</div><div class="line">                __strong __typeof(weakOperation) strongOperation = weakOperation;</div><div class="line">                if (strongOperation &amp;&amp; !strongOperation.isCancelled) &#123;</div><div class="line">                    completedBlock(image, nil, cacheType, YES, url);</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">            </div><div class="line">            ...</div><div class="line">        &#125;</div><div class="line">        else &#123;</div><div class="line">           ...</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line">    </div><div class="line">    return operation;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>0.查询本地（内存、磁盘）缓存  </p>
<p>1.本地没有缓存，从网络上下载</p>
<p>2.下载完成后，缓存到本地（内存、磁盘）并返回</p>
<p>3.如果本地存在缓存（内存中有直接取出，磁盘中有存到内存中再取出） 直接取出 并返回</p>
<h2 id="是否有缓存-内存、磁盘-？"><a href="#是否有缓存-内存、磁盘-？" class="headerlink" title="是否有缓存(内存、磁盘)？"></a>是否有缓存(内存、磁盘)？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">// SDImageCache.m</div><div class="line"></div><div class="line">- (NSOperation *)queryDiskCacheForKey:(NSString *)key done:(SDWebImageQueryCompletedBlock)doneBlock &#123; // 0</div><div class="line">    if (!doneBlock) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (!key) &#123;</div><div class="line">        doneBlock(nil, SDImageCacheTypeNone);</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // First check the in-memory cache...</div><div class="line">    UIImage *image = [self imageFromMemoryCacheForKey:key]; // 1</div><div class="line">    if (image) &#123;</div><div class="line">        doneBlock(image, SDImageCacheTypeMemory);</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    NSOperation *operation = [NSOperation new]; // 2 </div><div class="line">    dispatch_async(self.ioQueue, ^&#123; // 3</div><div class="line">        if (operation.isCancelled) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @autoreleasepool &#123; // 4</div><div class="line">            UIImage *diskImage = [self diskImageForKey:key]; // 5</div><div class="line">            if (diskImage &amp;&amp; self.shouldCacheImagesInMemory) &#123;</div><div class="line">                NSUInteger cost = SDCacheCostForImage(diskImage);</div><div class="line">                [self.memCache setObject:diskImage forKey:key cost:cost]; // 6</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">                doneBlock(diskImage, SDImageCacheTypeDisk);</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    return operation;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>0.key 为 图片 URL 字符串 </p>
<p>1.去根据 key 查找内存中是否存在缓存的图片  </p>
<p>2.创建 IO Operation 最后方法会返回</p>
<p>3.异步串行队列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">_ioQueue = dispatch_queue_create(&quot;com.hackemist.SDWebImageCache&quot;, DISPATCH_QUEUE_SERIAL);</div></pre></td></tr></table></figure>
<p>4.创建自动释放池，使内存及时释放</p>
<p>5.从硬盘里取出图片  </p>
<p>6.缓存到内存</p>
<h2 id="没有缓存那就下载"><a href="#没有缓存那就下载" class="headerlink" title="没有缓存那就下载"></a>没有缓存那就下载</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div></pre></td><td class="code"><pre><div class="line">// SDWebImageDownloader.m</div><div class="line"></div><div class="line">- (id &lt;SDWebImageOperation&gt;)downloadImageWithURL:(NSURL *)url options:(SDWebImageDownloaderOptions)options progress:(SDWebImageDownloaderProgressBlock)progressBlock completed:(SDWebImageDownloaderCompletedBlock)completedBlock &#123;</div><div class="line">    __block SDWebImageDownloaderOperation *operation;</div><div class="line">    __weak __typeof(self)wself = self;</div><div class="line"></div><div class="line">    [self addProgressCallback:progressBlock completedBlock:completedBlock forURL:url createCallback:^&#123;</div><div class="line">        NSTimeInterval timeoutInterval = wself.downloadTimeout;</div><div class="line">        if (timeoutInterval == 0.0) &#123;</div><div class="line">            timeoutInterval = 15.0; // 0</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 1</div><div class="line">        // In order to prevent from potential duplicate caching (NSURLCache + SDImageCache) we disable the cache for image requests if told otherwise</div><div class="line">        NSMutableURLRequest *request = [[NSMutableURLRequest alloc] initWithURL:url cachePolicy:(options &amp; SDWebImageDownloaderUseNSURLCache ? NSURLRequestUseProtocolCachePolicy : NSURLRequestReloadIgnoringLocalCacheData) timeoutInterval:timeoutInterval]; </div><div class="line">        request.HTTPShouldHandleCookies = (options &amp; SDWebImageDownloaderHandleCookies);</div><div class="line">        request.HTTPShouldUsePipelining = YES;</div><div class="line">        if (wself.headersFilter) &#123;</div><div class="line">            request.allHTTPHeaderFields = wself.headersFilter(url, [wself.HTTPHeaders copy]);</div><div class="line">        &#125;</div><div class="line">        else &#123;</div><div class="line">            request.allHTTPHeaderFields = wself.HTTPHeaders;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        // 2</div><div class="line">        operation = [[wself.operationClass alloc] initWithRequest:request</div><div class="line">                                                          options:options</div><div class="line">                                                         progress:^(NSInteger receivedSize, NSInteger expectedSize) &#123; // 3</div><div class="line">                                                             SDWebImageDownloader *sself = wself;</div><div class="line">                                                             if (!sself) return;</div><div class="line">                                                             __block NSArray *callbacksForURL;</div><div class="line">                                                             dispatch_sync(sself.barrierQueue, ^&#123;</div><div class="line">                                                                 callbacksForURL = [sself.URLCallbacks[url] copy];</div><div class="line">                                                             &#125;);</div><div class="line">                                                             for (NSDictionary *callbacks in callbacksForURL) &#123;</div><div class="line">                                                                 dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">                                                                     SDWebImageDownloaderProgressBlock callback = callbacks[kProgressCallbackKey];</div><div class="line">                                                                     if (callback) callback(receivedSize, expectedSize);</div><div class="line">                                                                 &#125;);</div><div class="line">                                                             &#125;</div><div class="line">                                                         &#125;</div><div class="line">                                                        completed:^(UIImage *image, NSData *data, NSError *error, BOOL finished) &#123; // 4</div><div class="line">                                                            SDWebImageDownloader *sself = wself;</div><div class="line">                                                            if (!sself) return;</div><div class="line">                                                            __block NSArray *callbacksForURL;</div><div class="line">                                                            dispatch_barrier_sync(sself.barrierQueue, ^&#123;</div><div class="line">                                                                callbacksForURL = [sself.URLCallbacks[url] copy];</div><div class="line">                                                                if (finished) &#123;</div><div class="line">                                                                    [sself.URLCallbacks removeObjectForKey:url];</div><div class="line">                                                                &#125;</div><div class="line">                                                            &#125;);</div><div class="line">                                                            for (NSDictionary *callbacks in callbacksForURL) &#123;</div><div class="line">                                                                SDWebImageDownloaderCompletedBlock callback = callbacks[kCompletedCallbackKey];</div><div class="line">                                                                if (callback) callback(image, data, error, finished);</div><div class="line">                                                            &#125;</div><div class="line">                                                        &#125;</div><div class="line">                                                        cancelled:^&#123;</div><div class="line">                                                            SDWebImageDownloader *sself = wself;</div><div class="line">                                                            if (!sself) return;</div><div class="line">                                                            dispatch_barrier_async(sself.barrierQueue, ^&#123;</div><div class="line">                                                                [sself.URLCallbacks removeObjectForKey:url];</div><div class="line">                                                            &#125;);</div><div class="line">                                                        &#125;];</div><div class="line">        operation.shouldDecompressImages = wself.shouldDecompressImages;</div><div class="line">        </div><div class="line">        if (wself.urlCredential) &#123;</div><div class="line">            operation.credential = wself.urlCredential;</div><div class="line">        &#125; else if (wself.username &amp;&amp; wself.password) &#123;</div><div class="line">            operation.credential = [NSURLCredential credentialWithUser:wself.username password:wself.password persistence:NSURLCredentialPersistenceForSession];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        // 4</div><div class="line">        if (options &amp; SDWebImageDownloaderHighPriority) &#123;</div><div class="line">            operation.queuePriority = NSOperationQueuePriorityHigh;</div><div class="line">        &#125; else if (options &amp; SDWebImageDownloaderLowPriority) &#123;</div><div class="line">            operation.queuePriority = NSOperationQueuePriorityLow;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        [wself.downloadQueue addOperation:operation]; // 5</div><div class="line">        if (wself.executionOrder == SDWebImageDownloaderLIFOExecutionOrder) &#123;</div><div class="line">            // Emulate LIFO execution order by systematically adding new operations as last operation&apos;s dependency</div><div class="line">            [wself.lastAddedOperation addDependency:operation];</div><div class="line">            wself.lastAddedOperation = operation;</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">    return operation;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>0.下载超时时间设置。默认：15 秒  </p>
<p>1.<code>NSMutableURLRequest</code> 设置。即请求设置</p>
<p>2.下载 <code>Operation</code>。即 <code>SDWebImageDownloaderOperation</code> ，它继承自 NSOperation 的并发操作。</p>
<p>3.下载进度  </p>
<p>4.操作优先级  </p>
<p>5.将下载操作添加至下载队列  </p>
</div></article></div></section><footer><div class="paginator"><a href="/2016/04/24/sdwebimage-2/" class="prev">上一篇</a><a href="/2016/04/10/she-zhi-ios-zhuang-tai-lan-yang-shi/" class="next">下一篇</a></div><div data-thread-key="2016/04/24/sdwebimage-1/" data-title="阅读 SDWebImage 源码（一）" data-url="http://iYiming.me/2016/04/24/sdwebimage-1/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"jiajiayouba"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>© 2014 - 2016 <a href="http://iYiming.me">iYiming</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1253468447'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s6.cnzz.com/z_stat.php%3Fid%3D1253468447%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "//hm.baidu.com/hm.js?3cec0b24b46b86302d1aa3b050d4668f";var s = document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm, s);})();</script></body></html>