<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 聊聊 GCD · 一鸣的博客</title><meta name="description" content="聊聊 GCD - iYiming"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.jpg"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://iYiming.me/atom.xml" title="一鸣的博客"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.jpg"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/jiajiayouba" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/iYiming" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">聊聊 GCD</h1><div class="post-info">2016年1月21日</div><div class="post-content"><p><img src="/images/liao_liao_GCD/0.png" alt="liao_liao_GCD"></p>
<h2 id="什么是-GCD"><a href="#什么是-GCD" class="headerlink" title="什么是 GCD"></a>什么是 GCD</h2><p>GCD (Grand Central Dispatch) 是 iOS 多任务的核心。在 Mac OS X 10.6 雪豹中首次推出，后被引入到了 iOS 4.0 中。GCD 是基于 C 的 API，是底层的框架，<code>NSOperationQueue</code> 是在 GCD 的基础上实现的。  </p>
<p>GCD 和 Block 的配合使用，可以方便地进行多线程编程。</p>
<h2 id="GCD-包含什么内容"><a href="#GCD-包含什么内容" class="headerlink" title="GCD 包含什么内容"></a>GCD 包含什么内容</h2><p>分派队列（dispatch queue），分派组（dispatch group），分派屏障（dispatch barrier）。</p>
<p>除了上面几个比较常用的 GCD 还包含下面几个内容：    </p>
<p>分派信号量（dispatch semaphores）、分派源（dispatch sources）、分派数据（dispatch data）以及分派 I/O 。</p>
<p>本文仅介绍 分派队列，分派组，分派屏障 GCD 常用内容。</p>
<h2 id="同步、异步，并行、串行，并行、并发-概念"><a href="#同步、异步，并行、串行，并行、并发-概念" class="headerlink" title="同步、异步，并行、串行，并行、并发 概念"></a>同步、异步，并行、串行，并行、并发 概念</h2><p>同步  </p>
<p>所谓同步，就是在发出一个功能调用时，在没有得到结果之前，该调用就不返回。</p>
<p>同步代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t concurrentQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div><div class="line"></div><div class="line">dispatch_sync(concurrentQueue, ^()&#123;</div><div class="line">   NSLog(@&quot;A&quot;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">dispatch_sync(concurrentQueue, ^()&#123;</div><div class="line">   NSLog(@&quot;B&quot;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// 先输出 A 后输出 B 。</div></pre></td></tr></table></figure>
<p>异步</p>
<p>异步的概念和同步相对。当一个异步过程调用发出后，调用者立刻得到结果就执行下面的功能。</p>
<p>异步代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t concurrentQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div><div class="line"></div><div class="line">dispatch_async(concurrentQueue, ^()&#123;</div><div class="line">   NSLog(@&quot;A&quot;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">dispatch_async(concurrentQueue, ^()&#123;</div><div class="line">   NSLog(@&quot;B&quot;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// 可能先输出 A 后输出 B ，也可能先输出 B 后输出 A。因为异步下是没执行完就执行下面的功能</div></pre></td></tr></table></figure>
<p>并行与并发区别</p>
<p>当有多个线程在操作时,如果系统只有一个 CPU,则它根本不可能真正同时进行一个以上的线程,它只能把 CPU 运行时间划分成若干个时间段,再将时间段分配给各个线程执行,在一个时间段的线程代码运行时,其它线程处于挂起状态.这种方式我们称之为并发(Concurrent).  </p>
<p>当系统有一个以上 CPU 时,则线程的操作有可能非并发.当一个 CPU 执行一个线程时,另一个CPU 可以执行另一个线程,两个线程互不抢占 CPU 资源,可以同时进行,这种方式我们称之为并行(Parallel)</p>
<h2 id="分配队列"><a href="#分配队列" class="headerlink" title="分配队列"></a>分配队列</h2><p>串行队列（一个队列一个队列的执行）：</p>
<ul>
<li><p>主队列。最常见的串行队列。使用 <code>dispatch_get_main_queue()</code> 获得。</p>
</li>
<li><p>自己创建的串行队列。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t serialQueue = dispatch_queue_create(&quot;me.iYiming.serialQueue&quot;, DISPATCH_QUEUE_SERIAL);</div></pre></td></tr></table></figure>
<p> 或者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t serialQueue = dispatch_queue_create(&quot;me.iYiming.serialQueue&quot;, NULL);</div></pre></td></tr></table></figure>
<p>并发队列（几个队列“同时”执行）：</p>
<ul>
<li>系统队列 </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#define DISPATCH_QUEUE_PRIORITY_HIGH 2 // 高</div><div class="line">#define DISPATCH_QUEUE_PRIORITY_DEFAULT 0 // 默认</div><div class="line">#define DISPATCH_QUEUE_PRIORITY_LOW (-2) // 低</div><div class="line">#define DISPATCH_QUEUE_PRIORITY_BACKGROUND INT16_MIN //最低</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t concurrentQueue = dispatch_get_global_queue(XXXX, 0); // 并发队列  XXXX 表示 上面的四个参数，</div></pre></td></tr></table></figure>
<ul>
<li>自己创建的并发队列</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t concurrentQueue = dispatch_queue_create(&quot;me.iYiming.concurrentQueue&quot;, DISPATCH_QUEUE_CONCURRENT);</div></pre></td></tr></table></figure>
<p>补充：</p>
<p><code>dispatch_set_target_queue()</code> 用法：  </p>
<p>设置自己创建队列的目标队列，使创建的队列优先级和目标队列一样。</p>
<p><a href="http://blog.csdn.net/growinggiant/article/details/41077221" target="_blank" rel="external">http://blog.csdn.net/growinggiant/article/details/41077221</a>  </p>
<p>上文中说了种情况：</p>
<blockquote>
<p>一般都是把一个任务放到一个串行的queue中，如果这个任务被拆分了，被放置到<strong>多个串行的 queue 中</strong>，但实际还是需要这个任务同步执行，那么就会有问题，因为多个串行 queue 之间是并行的。  </p>
<p>那该如何是好呢？  </p>
<p>这是就可以使用 <code>dispatch_set_target_queue</code> 了。<br>如果将多个串行的 queue 使用 <code>dispatch_set_target_queue</code> 指定到了同一目标，那么着多个串行 queue 在目标 queue 上就是同步执行的，不再是并行执行。</p>
</blockquote>
<p>除了上面链接中说到的用处外（也可以用别的方式替代），感觉没多大用处？！</p>
<h2 id="分配组"><a href="#分配组" class="headerlink" title="分配组"></a>分配组</h2><p>关于使用分配组，我用到的情况就是这个情形下：执行 A 任务, B 任务后(A B 可以同时做)，最后再做 C 任务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t concurrentQueue = dispatch_queue_create(&quot;me.iYiming.concurrentQueue&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class="line"></div><div class="line">dispatch_group_t group = dispatch_group_create();</div><div class="line"></div><div class="line">dispatch_group_async(group, concurrentQueue, ^&#123;</div><div class="line">   // A 任务</div><div class="line">&#125;);</div><div class="line"></div><div class="line">dispatch_group_async(group, concurrentQueue, ^&#123;</div><div class="line">   // B 任务</div><div class="line">&#125;);</div><div class="line"></div><div class="line">dispatch_group_notify(group, concurrentQueue, ^&#123;</div><div class="line">   // C 任务</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="分配屏障"><a href="#分配屏障" class="headerlink" title="分配屏障"></a>分配屏障</h2><p>我们使用分配屏障会等当前队列执行处理全部结束后，再将指定的处理追加到该队列上，然后再由分配屏障追加 的处理执行完毕后，当前队列才恢复为一般的动作，追加到该队列的处理又开始执行。</p>
<p>代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t myQueue = dispatch_get_global_queue(0, 0);</div><div class="line">   </div><div class="line">dispatch_async(myQueue, ^&#123;</div><div class="line">   NSLog(@&quot;123&quot;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">dispatch_async(myQueue, ^&#123;</div><div class="line">   NSLog(@&quot;456&quot;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">dispatch_barrier_async(myQueue, ^&#123;</div><div class="line">   NSLog(@&quot;789&quot;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">dispatch_async(myQueue, ^&#123;</div><div class="line">   NSLog(@&quot;10&quot;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>输出结果，先输出 <code>123</code> 或者 <code>456</code>，再输出 <code>789</code>，最后才输出 <code>10</code>。</p>
<p>举个例子</p>
<p>我们都会对数据进行读写操作，为了防止多个线程对数据进行安全访问。我们需要使用锁来实现某种同步机制。</p>
<p>在 GCD 出现之前，有两种办法：</p>
<ul>
<li>采用内置的“同步块”</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (void)synchronizationMethod &#123;</div><div class="line">     @synchronized(self) &#123;</div><div class="line">         // 使用同步块</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<ul>
<li>直接使用 <code>NSLock</code> 对象（也可以使用 <code>NSRecursiveLock</code> 这种递归锁）。  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">_lock = [[NSLock alloc] init];</div><div class="line"></div><div class="line">- (void)synchronizationMethod &#123;</div><div class="line">    [_lock lock];</div><div class="line">    //NSLock 对象方式</div><div class="line">    [_lock unlock];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>互斥锁分为递归锁和非递归锁。</p>
<p>同一个线程可以多次获取同一个递归锁，不会产生死锁。<br>如果一个线程多次获取同一个非递归锁，则会产生死锁。</p>
</blockquote>
<p>这两种方法都很好，不过也有其缺陷。比方说：  </p>
<ul>
<li><p>在极端情况下，同步块会导致死锁，另外，其效率也不见得高.</p>
</li>
<li><p>滥用 <code>@sychronized(self)</code> 会很危险，因为所有同步块都会彼此抢夺同一个锁。要是有很多歌属性都这么写的话，那么每个属性的同步块都要等其他所有同步块执行完毕才能执行，这也许不是我们想要的结果。</p>
</li>
</ul>
<p>我们可以使用 “串行同步队列”，将读取操作及写入操作都安排在同一个队列里，即可保证数据同步。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">_serialQueue = dispatch_queue_create(&quot;me.iYiming.serialQueue&quot;, DISPATCH_QUEUE_SERIAL);</div><div class="line">        </div><div class="line">- (NSString *)someString &#123;</div><div class="line">    __block NSString *localSomeString;</div><div class="line">    </div><div class="line">    __weak typeof(self) wakeSelf = self;</div><div class="line">    dispatch_sync(_serialQueue, ^&#123;</div><div class="line">        localSomeString = wakeSelf.someString;</div><div class="line">    &#125;);</div><div class="line">    return localSomeString;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)setSomeString:(NSString *)someString &#123;</div><div class="line">    __weak typeof(self) wakeSelf = self;</div><div class="line">    dispatch_sync(_serialQueue, ^&#123;</div><div class="line">        wakeSelf.someString = someString;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>还可以进一步优化。设置方法并不一定非得是同步的。设置实例变量所用的块，并不需要向设置返回什么值。也就是可以修改成如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (void)setSomeString:(NSString *)someString &#123;</div><div class="line">    __weak typeof(self) wakeSelf = self;</div><div class="line">    dispatch_async(_serialQueue, ^&#123;</div><div class="line">        wakeSelf.someString = someString;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但经过测试一下程序性能，那么可能会发现这种写法比原来慢，因为执行异步派发时，需要拷贝块。若拷贝所用的时间明显超过执行块所花的时间，则这种做法将比原来更慢。</p>
<p>多个获取方法可以并发执行，而获取方法与设置方法之间不能并发执行，利用这个特点，还能写出更快一些的代码来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">_concurrentQueue = dispatch_queue_create(&quot;me.iYiming.concurrentQueue&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class="line"></div><div class="line">- (NSString *)someString &#123;</div><div class="line">    __block NSString *localSomeString;</div><div class="line">    </div><div class="line">    __weak typeof(self) wakeSelf = self;</div><div class="line">    dispatch_sync(_concurrentQueue, ^&#123;</div><div class="line">        localSomeString = wakeSelf.someString;</div><div class="line">    &#125;);</div><div class="line">    return localSomeString;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)setSomeString:(NSString *)someString &#123;</div><div class="line">    __weak typeof(self) wakeSelf = self;</div><div class="line">    dispatch_barrier_sync(_concurrentQueue, ^&#123; // 同步屏障</div><div class="line">        wakeSelf.someString = someString;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>使用 并发队列 和 分配屏障 可实现高效率的数据库访问和文件访问。</strong></p>
<h2 id="GCD-VS-NSOperation"><a href="#GCD-VS-NSOperation" class="headerlink" title="GCD VS NSOperation"></a>GCD VS NSOperation</h2><p>GCD 的优点：  </p>
<ol>
<li>GCD 提供的 <code>dispatch_after</code> 支持调度下一个操作的开始时间而不是直接进入睡眠。</li>
<li><code>NSOperation</code> 中没有类似 <code>dispatch_source_t</code>,<code>dispatch_io</code>,<code>dispatch_data_t</code>,<code>dispatch_semaphore_t</code> 等操作。  </li>
</ol>
<p><code>NSOperation</code> 的优点：  </p>
<ol>
<li>GCD 没有操作依赖。我们可以让一个 Operation 依赖于另一个 Operation，这样的话尽管两个 Operation 处于同一个并行队列中，但前者会直到后者执行完毕后再执行；</li>
<li>GCD 没有操作优先级（ GCD 有队列优先级），能够使同一个并行队列中的任务区分先后地执行，而在 GCD 中，我们只能区分不同任务队列的优先级，如果要区分block任务的优先级，也需要大量的复杂代码；</li>
<li>GCD 没有 KVO。<code>NSOperation</code> 可以监听一个 Operation 是否完成或取消，这样能比GCD 更加有效地掌控我们执行的后台任务</li>
<li>在 <code>NSOperationQueue</code> 中，我们可以随时取消已经设定要准备执行的任务(当然，已经开始的任务就无法阻止了)，而 GCD 没法停止已经加入 queue 的 Block(其实是有的，但需要许多复杂的代码)</li>
<li>我们能够对 <code>NSOperation</code> 进行继承，在这之上添加成员变量与成员方法，提高整个代码的复用度，这比简单地将 block 任务排入执行队列更有自由度，能够在其之上添加更多自定制的功能。</li>
</ol>
<h2 id="使用-dispatch-once-创建单例"><a href="#使用-dispatch-once-创建单例" class="headerlink" title="使用 dispatch_once 创建单例"></a>使用 <code>dispatch_once</code> 创建单例</h2><p>直接上代码：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">//保存单例对象的静态全局变量</div><div class="line">static id _instance;</div><div class="line">+ (instancetype)sharedTools &#123;</div><div class="line">    return [[self alloc]init];</div><div class="line">&#125;</div><div class="line">//在调用alloc方法之后，最终会调用allocWithZone方法</div><div class="line">+ (instancetype)allocWithZone:(struct _NSZone *)zone &#123;</div><div class="line">    //保证分配内存的代码只执行一次</div><div class="line">    static dispatch_once_t onceToken;</div><div class="line">    dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">        _instance = [super allocWithZone:zone];</div><div class="line">    &#125;);</div><div class="line">    return _instance;</div><div class="line">&#125;</div><div class="line">//这是个对象方法，既然有对象而且是单例，那么调用者就是这个单例对象了，那就返回调用的对象就行</div><div class="line">- (id)copyWithZone:(NSZone *)zone &#123;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line">//这是个对象方法，既然有对象而且是单例，那么调用者就是这个单例对象了，那就返回调用的对象就行</div><div class="line">- (id)mutableCopyWithZone:(NSZone *)zone &#123;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line">#if __has_feature(objc_arc)</div><div class="line">//如果是ARC环境</div><div class="line">#else</div><div class="line">//如果不是ARC环境</div><div class="line"></div><div class="line">//既然是单例对象，总不能被人给销毁了吧，一旦销毁了，分配内存的代码已经执行过了，就再也不能创建对象了。所以覆盖掉release操作</div><div class="line">- (oneway void)release &#123;</div><div class="line">&#125;</div><div class="line">//这是个对象方法，既然有对象而且是单例，那么调用者就是这个单例对象了，那就返回调用的对象就行</div><div class="line">- (instancetype)retain &#123;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line">//为了便于识别，这里返回 MAXFLOAT ，别的程序员看到这个数据，就能意识到这是单例了。纯属装逼……</div><div class="line">- (NSUInteger)retainCount &#123;</div><div class="line">    return MAXFLOAT;</div><div class="line">&#125;</div><div class="line">#endif</div></pre></td></tr></table></figure>
<p>当然还有种方式 是使用上面那种 使用 <code>@synchronized()</code> 方式。但 <code>dispatch_once</code> 更高效，它没有使用重量级的同步机制，若是那样做的话，每次运行代码前都要获取锁，相反，此函数采用 “原子访问”来查询标记，以判断其所对应的代码原来是否已经执行过。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="http://www.cnblogs.com/NickyYe/archive/2008/12/01/1344802.html" target="_blank" rel="external">http://www.cnblogs.com/NickyYe/archive/2008/12/01/1344802.html</a>  </p>
<p><a href="http://www.tanhao.me/pieces/616.html/" target="_blank" rel="external">http://www.tanhao.me/pieces/616.html/</a>  </p>
<p><a href="http://blog.csdn.net/likendsl/article/details/8568961" target="_blank" rel="external">http://blog.csdn.net/likendsl/article/details/8568961</a>  </p>
<p><a href="http://stackoverflow.com/questions/15629696/why-my-completionblock-never-gets-called-in-an-nsoperation" target="_blank" rel="external">http://stackoverflow.com/questions/15629696/why-my-completionblock-never-gets-called-in-an-nsoperation</a>  </p>
<p><a href="http://blog.csdn.net/hufengvip/article/details/11687699" target="_blank" rel="external">http://blog.csdn.net/hufengvip/article/details/11687699</a>  </p>
<p><a href="http://www.jianshu.com/p/d09e2638eb27" target="_blank" rel="external">http://www.jianshu.com/p/d09e2638eb27</a>  </p>
<p><a href="http://stackoverflow.com/questions/7651551/why-should-i-choose-gcd-over-nsoperation-and-blocks-for-high-level-applications" target="_blank" rel="external">http://stackoverflow.com/questions/7651551/why-should-i-choose-gcd-over-nsoperation-and-blocks-for-high-level-applications</a>  </p>
</div></article></div></section><footer><div class="paginator"><a href="/2016/03/27/yi-ge-nian-xing-dong-hua-de-yuan-ma-fen-xi/" class="prev">上一篇</a><a href="/2015/12/20/2015-wo-de-shu-dan/" class="next">下一篇</a></div><div data-thread-key="2016/01/21/liao-liao-gcd/" data-title="聊聊 GCD" data-url="http://iYiming.me/2016/01/21/liao-liao-gcd/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"jiajiayouba"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>© 2014 - 2016 <a href="http://iYiming.me">iYiming</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1253468447'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s6.cnzz.com/z_stat.php%3Fid%3D1253468447%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));
    var _hmt = _hmt || [];
    (function() {
    var hm = document.createElement("script");
    hm.src = "//hm.baidu.com/hm.js?3cec0b24b46b86302d1aa3b050d4668f";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
    })();</script></body></html>