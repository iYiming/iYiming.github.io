<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 第 5 章 内存管理 · 一鸣的博客</title><meta name="description" content="第 5 章 内存管理 - iYiming"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.jpg"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://iYiming.me/atom.xml" title="一鸣的博客"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.jpg"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/jiajiayouba" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/iYiming" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">第 5 章 内存管理</h1><div class="post-info">2016年6月5日</div><div class="post-content"><p><img src="/images/effective_objectivec_2.0/1.jpg" alt="1.jpg"></p>
<p>下图列出了一些 ARC 下的内存问题，就各个问题一一描述下： </p>
<p><img src="/images/effective_objectivec_2.0/2.png" alt="2.jpg"></p>
<h2 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h2><h4 id="普通的两个变量互相引用"><a href="#普通的两个变量互相引用" class="headerlink" title="普通的两个变量互相引用"></a>普通的两个变量互相引用</h4><p>上代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">self.object1 = [[YMNormalCircularReferenceObject alloc] init];</div><div class="line">self.object2 = [[YMNormalCircularReferenceObject alloc] init];</div><div class="line"></div><div class="line">self.object1.data = self.object2;</div><div class="line">self.object2.data = self.object1;</div></pre></td></tr></table></figure>
<p>两个对象互相引用，解决办法一个使用 <code>weak</code> 标识属性。</p>
<h4 id="Block-循环引用"><a href="#Block-循环引用" class="headerlink" title="Block 循环引用"></a>Block 循环引用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">#import &quot;YMBlockCircularReferenceViewController.h&quot;</div><div class="line"></div><div class="line">typedef void(^YMDownloaderCompleteBlock)(id data);</div><div class="line"></div><div class="line">@interface YMDownloader ()</div><div class="line"></div><div class="line">@property (nonatomic, copy) YMDownloaderCompleteBlock downloaderCompleteBlock;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation YMDownloader</div><div class="line"></div><div class="line"></div><div class="line">- (void)downloadDataWithURL:(NSURL *)url completeBlock:(YMDownloaderCompleteBlock)block &#123;</div><div class="line">    self.downloaderCompleteBlock = block;</div><div class="line">    </div><div class="line">    [self downloadDataWithURL:url];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)downloadDataWithURL:(NSURL *)url &#123;</div><div class="line">    dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</div><div class="line">        sleep(2);</div><div class="line">        </div><div class="line">        self.downloaderCompleteBlock(url);</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line"></div><div class="line">@interface YMBlockCircularReferenceViewController ()</div><div class="line"></div><div class="line">@property (nonatomic, strong) YMDownloader *downloader;</div><div class="line">@property (nonatomic, strong) id data;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation YMBlockCircularReferenceViewController</div><div class="line"></div><div class="line">- (void)viewDidLoad &#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    </div><div class="line">    self.downloader = [[YMDownloader alloc] init];</div><div class="line">    [self.downloader downloadDataWithURL:[NSURL URLWithString:@&quot;&quot;] completeBlock:^(id data) &#123;</div><div class="line">        self.data = data;</div><div class="line">    &#125;];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)dealloc &#123;</div><div class="line">    NSLog(@&quot;YMBlockCircularReferenceViewController dealloc 方法&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p><code>self</code> 保留了 <code>downloader</code> ，<code>downloader</code> 拷贝了块，块里保留了 <code>self</code>,解决办法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (void)downloadDataWithURL:(NSURL *)url &#123;</div><div class="line">    dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</div><div class="line">        sleep(2);</div><div class="line">        </div><div class="line">        self.downloaderCompleteBlock(url);</div><div class="line">        self.downloaderCompleteBlock = nil;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="NSTimer"><a href="#NSTimer" class="headerlink" title="NSTimer"></a>NSTimer</h4><p><code>NSTimer</code> 会保留其目标对象</p>
<p>继续上代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">#import &quot;YMTimerCircularReferenceViewController.h&quot;</div><div class="line"></div><div class="line">@interface YMTimerCircularReferenceViewController ()</div><div class="line"></div><div class="line">@property (nonatomic, strong) NSTimer *timer;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation YMTimerCircularReferenceViewController</div><div class="line"></div><div class="line">- (void)viewDidLoad &#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    </div><div class="line">    self.timer = [NSTimer timerWithTimeInterval:1 target:self selector:@selector(timerSelector) userInfo:nil repeats:YES];</div><div class="line">    [[NSRunLoop currentRunLoop] addTimer:self.timer forMode:NSDefaultRunLoopMode];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)timerSelector &#123;</div><div class="line">    NSLog(@&quot;%@&quot;,[NSDate date]);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)dealloc &#123;</div><div class="line">    NSLog(@&quot;YMTimerCircularReferenceViewController dealloc&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当 <code>YMTimerCircularReferenceViewController</code> pop 时，上面的 <code>dealloc</code>方法不被调用。</p>
<p>解决办法，加一个 <code>NSTimer</code> 类别：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">#import &quot;NSTimer+YMBlock.h&quot;</div><div class="line"></div><div class="line">@implementation NSTimer (YMBlock)</div><div class="line"></div><div class="line">+ (NSTimer * _Nonnull)ym_timerWithTimeInterval:(NSTimeInterval)ti block:(nullable void (^)())block userInfo:(nullable id)userInfo repeats:(BOOL)yesOrNo &#123;</div><div class="line">    return [self timerWithTimeInterval:ti target:self selector:@selector(ym_blockInvoke:) userInfo:[block copy] repeats:yesOrNo];</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (void)ym_blockInvoke:(NSTimer *)timer &#123;</div><div class="line">    void (^block)() = timer.userInfo;</div><div class="line">    </div><div class="line">    if (block) &#123;</div><div class="line">        block();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>注：此处虽然依然有保留换，<code>self</code> 引用 <code>self</code>，因为是类对象，无须回收。<code>CADisplayLink</code> 类似。</p>
<h4 id="悬挂指针"><a href="#悬挂指针" class="headerlink" title="悬挂指针"></a>悬挂指针</h4><p>在 Scheme 中开启即可，如下图：</p>
<p><img src="/images/effective_objectivec_2.0/3.png" alt="3.jpg"></p>
<h2 id="持有、释放不匹配"><a href="#持有、释放不匹配" class="headerlink" title="持有、释放不匹配"></a>持有、释放不匹配</h2><h4 id="performselector"><a href="#performselector" class="headerlink" title="performselector"></a>performselector</h4><p>使用 <code>performSelector</code>,编译器并不知道将要调用的选择子是什么，因此，也就不了解其方法签名及返回值，甚至连是否有返回值都不清楚。而且，由于编译器不知道方法名，所以就没办法运用 ARC 的内存管理规则来判定返回值是不是应该释放。鉴于此，ARC 采用了比较谨慎的做法，就是不添加释放操作。然而这么做可能导致内存泄漏，因为方法在返回对象时可能已经将其保留了。</p>
<h4 id="CoreFoundation-Foundation"><a href="#CoreFoundation-Foundation" class="headerlink" title="CoreFoundation - Foundation"></a>CoreFoundation - Foundation</h4><p>上代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">- (IBAction)coreFoundationToFoundation:(id)sender &#123;</div><div class="line">   CFStringRef coreFoundationStr = CFStringCreateWithCString(NULL, &quot;Hello World!&quot;, kCFStringEncodingUnicode);</div><div class="line">    </div><div class="line">    NSString *foundationStr = (__bridge NSString *)(coreFoundationStr);</div><div class="line">    // NSString *foundationStr = CFBridgingRelease(coreFoundationStr);</div><div class="line">    </div><div class="line">    NSLog(@&quot;foundationStr:%@&quot;,foundationStr);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (IBAction)foundationToCoreFoundation:(id)sender &#123;</div><div class="line">    NSString *foundationStr = [[NSString alloc] initWithFormat:@&quot;Hello World!&quot;];</div><div class="line">    </div><div class="line">    CFStringRef coreFoundationStr = CFBridgingRetain(foundationStr);</div><div class="line">    NSLog(@&quot;coreFoundationStr:%@&quot;,coreFoundationStr);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (IBAction)noMemoryManagement:(id)sender &#123;</div><div class="line">    // NSString *foundationStr = @&quot;Hello World!&quot;;</div><div class="line">    // CFStringRef coreFoundationStr = (__bridge CFStringRef)(foundationStr);</div><div class="line">    </div><div class="line">    </div><div class="line">    // CFStringRef coreFoundationStr = CFStringCreateWithCString(NULL, &quot;Hello World!&quot;, kCFStringEncodingUnicode);</div><div class="line">    // NSString *foundationStr = (__bridge NSString *)(coreFoundationStr);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Core Foundation 与 Foundation 内存问题</p>
<p><code>__bridge</code> 什么也不做，仅仅是转换。此种情况下：  </p>
<ol>
<li>从 Cocoa 转换到 Core，需要人工 <code>CFRetain</code>，否则，Cocoa 指针释放后， 传出去的指针则无效。</li>
<li>从 Core 转换到 Cocoa，需要人工 <code>CFRelease</code>，否则，Cocoa 指针释放后，对象引用计数仍为1，不会被销毁。</li>
</ol>
<p><code>__bridge_retained</code> 转换后自动调用 <code>CFRetain</code>，即帮助自动解决上述 1 的情形。</p>
<p><code>__bridge_transfer</code> 转换后自动调用 <code>CFRelease</code>，即帮助自动解决上述 2 的情形。  </p>
<ul>
<li><code>__bridge</code> 用法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NSString *string = [NSString stringWithFormat:...];</div><div class="line">CFStringRef cfString = (__bridge CFStringRef)string;</div></pre></td></tr></table></figure>
<p>只是单纯地执行了类型转换，没有进行所有权的转移，也就是说，当 <code>string</code> 对象被释放的时候，<code>cfstring</code> 也不能被使用了。</p>
<ul>
<li><code>__bridge_retained</code> 用法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NSString *string = [NSString stringWithFormat:...];</div><div class="line">CFStringRef cfString = (__bridge_retained CFStringRef)string;</div><div class="line">...</div><div class="line">CFRelease(cfString); // 由于Core Foundation的对象不属于ARC的管理范畴，所以需要自己release</div></pre></td></tr></table></figure>
<p>使用 <code>__bridge_retained</code> 可以通过转换目标处（ <code>cfString</code> ）的 <code>retain</code> 处理，来使所有权转移。即使 <code>string</code> 变量被释放，<code>cfString</code> 还是可以使用具体的对象。只是有一点，由于 Core Foundation 的对象不属于 ARC 的管理范畴，所以需要自己 <code>release</code>。</p>
<p>可以用 <code>CFBridgingRetain</code> 替代 <code>__bridge_retained</code> 关键字：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NSString *string = [NSString stringWithFormat:...];</div><div class="line">CFStringRef cfString = CFBridgingRetain(string);</div><div class="line">...</div><div class="line">CFRelease(cfString); // 由于Core Foundation不在ARC管理范围内，所以需要主动release。</div></pre></td></tr></table></figure>
<ul>
<li><code>__bridge_transfer</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">CFStringRef cfString = CFStringCreate...();</div><div class="line">NSString *string = (__bridge_transfer NSString *)cfString;</div><div class="line"> </div><div class="line">// CFRelease(cfString); 因为已经用 __bridge_transfer 转移了对象的所有权，所以不需要调用 release</div></pre></td></tr></table></figure>
<p>所有权被转移的同时，被转换变量将失去对象的所有权。当 Core Foundation 对象类型向 Objective-C 对象类型转换的时候，会经常用到 <code>__bridge_transfer</code> 关键字。</p>
<p>同样，我们可以使用 <code>CFBridgingRelease()</code> 来代替 <code>__bridge_transfer</code> 关键字。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">CFStringRef cfString = CFStringCreate...();</div><div class="line">NSString *string = CFBridgingRelease(cfString);</div></pre></td></tr></table></figure>
<p>— 华丽分割线 —</p>
<p>其实看完上面的解释，就不用介绍上面代码出现的问题了。简要说下：</p>
<p>0.<code>- (IBAction)coreFoundationToFoundation:(id)sender</code> 方法创建了 CFStringRef 对象，并未使用，需要使用下面代码释放：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSString *foundationStr = CFBridgingRelease(coreFoundationStr);</div></pre></td></tr></table></figure>
<p>1.<code>- (IBAction)foundationToCoreFoundation:(id)sender</code> 方法里接手并<code>retain</code> 了 Objective-C 对象的字符串，但是没有做到释放。</p>
<h4 id="try-…-catch"><a href="#try-…-catch" class="headerlink" title="@try … @catch"></a>@try … @catch</h4><p>再上代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">- (void)viewDidLoad &#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    </div><div class="line">    @try &#123;</div><div class="line">        NSArray *array = @[@&quot;a&quot;, @&quot;b&quot;, @&quot;c&quot;];</div><div class="line">        [array objectAtIndex:3];</div><div class="line">    &#125; @catch (NSException *exception) &#123;</div><div class="line">        // 处理异常</div><div class="line">        NSLog(@&quot;throw an exception: %@&quot;, exception.reason);</div><div class="line">    &#125; @finally &#123;</div><div class="line">        NSLog(@&quot;正常执行&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当执行到 <code>[array objectAtIndex:3];</code> 发生崩溃，这时 <code>array</code> 并未释放，解决办法是开启编译器标志 <code>-fobjc-arc-exceptions</code></p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h4 id="autoreleasepool-block-降低内存峰值"><a href="#autoreleasepool-block-降低内存峰值" class="headerlink" title="@autoreleasepool block 降低内存峰值"></a>@autoreleasepool block 降低内存峰值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">for (id object in array) &#123;</div><div class="line">	@@autoreleasepool &#123;</div><div class="line">		...</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>合理运用自动释放池，可降低应用程序的内存峰值。</p>
<p>是否应该用 <code>@autoreleasepool { }</code> 来优化效率，完全取决于具体的应用程序。首先得监控内存用量，判断其中有没有需要解决的问题，如果没完成这一步，那就别急着优化。尽管<code>@autoreleasepool { }</code> 的开销不太大，但毕竟还是有的，所以尽量不要建立额外的自动释放池。</p>
<h4 id="需自己负责释放方法命名规则"><a href="#需自己负责释放方法命名规则" class="headerlink" title="需自己负责释放方法命名规则"></a>需自己负责释放方法命名规则</h4><p>在一开始的图中的几个方法，需要在 MRC 下需要对象自己手动释放。</p>
</div></article></div></section><footer><div class="paginator"><a href="/2016/06/05/di-6-zhang-kuai-yu-da-zhong-shu-pai-fa/" class="prev">上一篇</a><a href="/2016/06/05/di-4-zhang-xie-yi-yu-fen-lei/" class="next">下一篇</a></div><div data-thread-key="2016/06/05/di-5-zhang-nei-cun-guan-li/" data-title="第 5 章 内存管理" data-url="http://iYiming.me/2016/06/05/di-5-zhang-nei-cun-guan-li/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"jiajiayouba"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>© 2014 - 2016 <a href="http://iYiming.me">iYiming</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1253468447'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s6.cnzz.com/z_stat.php%3Fid%3D1253468447%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "//hm.baidu.com/hm.js?3cec0b24b46b86302d1aa3b050d4668f";var s = document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm, s);})();</script></body></html>