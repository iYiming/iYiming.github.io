<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Core Animation 学习之路 · 一鸣的博客</title><meta name="description" content="Core Animation 学习之路 - iYiming"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.jpg"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://iYiming.me/atom.xml" title="一鸣的博客"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.jpg"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/jiajiayouba" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/iYiming" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">Core Animation 学习之路</h1><div class="post-info">2014年10月25日</div><div class="post-content"><p>Core Animation 是一个图形渲染和动画的基础设施,既可以使用在 Mac OS X 上也可以使用在 iOS 上。利用 Core Animation，所有你需要做的就是配置一些动画参数（如起始和结束点）。Core Animation 使用硬件加速，所以流畅的动画不会加重 CPU 的负担从而减慢你的应用程序。<br><img src="/images/core_animation_guid/core_animation_guid_4.png" alt="Layer Subclass">  </p>
<h2 id="CALayer-对象"><a href="#CALayer-对象" class="headerlink" title="CALayer 对象"></a>CALayer 对象</h2><p>Layer 对象是使用 Core Animation 一切东西的核心。Layers 管理应用可视化内容，提供改变演示和可视化内容的选项。</p>
<h4 id="不同的-Layer-类提供专门的行为"><a href="#不同的-Layer-类提供专门的行为" class="headerlink" title="不同的 Layer 类提供专门的行为"></a>不同的 Layer 类提供专门的行为</h4><p>Core Animation 定义了许多标准的 Layer 类，他们种的每一个都提供特殊的用途。CALayer 是所有这些 Layer 类的基类。它定义了所有 Layer 队形必须支持的行为，是 layer-backed 视图默认的类型。然而，你也可以使用下图中特定的 Layer 类:<br><img src="/images/core_animation_guid/core_animation_guid_1.png" alt="Layer Subclass">  </p>
<h2 id="提供-Layer-的内容"><a href="#提供-Layer-的内容" class="headerlink" title="提供 Layer 的内容"></a>提供 Layer 的内容</h2><p>Layer 是数据对象 ，管理你应用程序提供的内容，一个 layer 的内容包括一个位图（包含你想展示的可视化的数据），你可以使用以下三种方式中的一种来提供位图的内容：<br>1.直接分配图片对象到 layer 对象的内容属性（对于从不或者很少改变的内容的 layer 是最好的一种技术<br>2.分配一个 delegate 对象到这个 layer，让这个 delegate 画出 layer 的内容（这种技术适用于 layer 内容周期性改变，可以提供一个额外的对象，比如 View）<br>3.定义一个 layer 子类，自己重写一个绘制方法来提供 layer 内容（这种技术适用于你需要创建一个 layer 子类或者你想改变 layer 的基础绘制行为）  </p>
<p>layer-backed 的视图（iOS 下都是）自动提供了 layer 的内容。  </p>
<h4 id="①使用一张图片作为-Layer-的内容"><a href="#①使用一张图片作为-Layer-的内容" class="headerlink" title="①使用一张图片作为 Layer 的内容"></a>①使用一张图片作为 Layer 的内容</h4><p>因为一个 layer 就是一个管理位图图片的容器，所以你可以分配一张图片直接到 layer 的contents 属性。分配一张图片到一个图层很容易 让你指定精准的你想要展示在屏幕上的图片。layer 直接使用你提供的图片内容，不会尝试重新创建这张图片的拷贝。这种行为可以减少内存消耗，在节省内存的情况下可以在多个地方使用相同的图像</p>
<p>你提供的图片必须是个 <code>CGImageRef</code> 类型（在 OS X v10.6或者以后，你可以直接提供<code>NSImage</code> 类型），提供图片的时候，请注意提供图片的分辨率适配真实设备分辨率。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">CALayer *imageLayer = [CALayer layer];</div><div class="line">imageLayer.backgroundColor = [UIColor redColor].CGColor;</div><div class="line">UIImage *layerImage = [UIImage imageNamed:@&quot;LayerImage.jpg&quot;];</div><div class="line">imageLayer.contents = (id)layerImage.CGImage;</div><div class="line">imageLayer.bounds = CGRectMake(0, 0, layerImage.size.width, layerImage.size.height);</div><div class="line">imageLayer.contentsScale = 2.0f;</div><div class="line">imageLayer.position = CGPointMake(layerImage.size.width/2.0f, layerImage.size.height/2.0f);</div><div class="line">[self.view.layer addSublayer:imageLayer];</div></pre></td></tr></table></figure>
<h4 id="②使用-delegate-来提供-layer-的内容"><a href="#②使用-delegate-来提供-layer-的内容" class="headerlink" title="②使用 delegate 来提供 layer 的内容"></a>②使用 delegate 来提供 layer 的内容</h4><p>如果你的 layer 内容是动态变化的，你可以使用 delegate 独享来提供和更新你想要的内容。展示时，layer 调取你的 delegate 方法来提供需要的内容<br>1）如果你的 delegate 实现了 <code>diplayLayer:</code>方法，这个实现响应创建一个位图和分配它到图层的content属性  </p>
<p><img src="/images/core_animation_guid/core_animation_guid_2.png" alt="Layer Subclass">   </p>
<p>2）如果你的协议实现了 <code>drawLayer：inContext：</code>方法，Core Animation 创建一个位图，创建一个 graphics context 来挥之位图，然后调取你的 delegate 方法来填充位图。所有你的协议方法会知道提供的 graphics context  </p>
<p><img src="/images/core_animation_guid/core_animation_guid_3.png" alt="Layer Subclass">  </p>
<p>备注：简单的说 displayLayer：方法，使用的内容是原本就有的 如图片等，而drawLayer：inContext：方法是在画布上画出一些内容。<br>协议必须实现 <code>displayLayer</code> 或者 <code>drawLayer：inContext</code> 方法，如果协议同时实现了这两个方法，这个 layer 仅会调用 <code>displayer:</code> 方法。<br>对于有自定义内容的 layer-backed 视图，你应该继续重写 view 的方法来实现你的绘制，layer-backed 视图自动让他、他的 layer 的 delegate 实现需要的 delegate 方法，你不能改变这种设置，而是应该实现你的 view 的 <code>drawRect:</code> 方法来绘制你的内容。  </p>
<h2 id="Layer-内容动画"><a href="#Layer-内容动画" class="headerlink" title="Layer 内容动画"></a>Layer 内容动画</h2><p>Core Animation 提供的基础框架使得创建一个 layer 优雅的动画变得容易。使用 Core Animation，仅改变一个属性你就可以创建动画，你也可以自己创建动画，明确的设置动画参数。  </p>
<h4 id="简单改变-Layer-属性动画"><a href="#简单改变-Layer-属性动画" class="headerlink" title="简单改变 Layer 属性动画"></a>简单改变 Layer 属性动画</h4><p>你可以实现一个简单的动画，明确的或者不明确的。不明确的动画使用默认的时间和动画属性来完成动画，明确的动画需要自己来设置这些属性。所以简单的动画适用于你想使用默认时间、代码量少的动画。  </p>
<p>不明确的动画写法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">theLayer.opacity = 0.0;</div></pre></td></tr></table></figure></p>
<p>明确的动画写法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">CABasicAnimation* fadeAnim = [CABasicAnimation animationWithKeyPath:@&quot;opacity&quot;];</div><div class="line">fadeAnim.fromValue = [NSNumber numberWithFloat:1.0];</div><div class="line">fadeAnim.toValue = [NSNumber numberWithFloat:0.0];</div><div class="line">fadeAnim.duration = 1.0;</div><div class="line">[theLayer addAnimation:fadeAnim forKey:@&quot;opacity&quot;];</div><div class="line"></div><div class="line">theLayer.opacity = 0.0;//必须要写</div></pre></td></tr></table></figure></p>
<h4 id="Keyframe-Animation-来改变-Layer-属性动画"><a href="#Keyframe-Animation-来改变-Layer-属性动画" class="headerlink" title="Keyframe Animation 来改变 Layer 属性动画"></a>Keyframe Animation 来改变 Layer 属性动画</h4><p>与CABasicAnimation（设置两个点 开始值、结束值）不同的是，一个CAKeyframeAnimation 可以设置一系列的目标值。例如改变边框粗细动画：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">CALayer *myLayer = [CALayer layer];</div><div class="line">myLayer.bounds = CGRectMake(0, 0, 100, 100);</div><div class="line">myLayer.position = CGPointMake(100, 200);</div><div class="line"></div><div class="line">CAKeyframeAnimation* widthAnim = [CAKeyframeAnimation animationWithKeyPath:@&quot;borderWidth&quot;];</div><div class="line">NSArray* widthValues = [NSArray arrayWithObjects:@1.0, @10.0, @5.0, @30.0, @0.5, @15.0, @2.0, @50.0, @0.0, nil];</div><div class="line">widthAnim.values = widthValues;</div><div class="line">widthAnim.calculationMode = kCAAnimationPaced;</div><div class="line">widthAnim.duration = 10.0f;</div><div class="line"></div><div class="line">[myLayer addAnimation:widthAnim forKey:@&quot;BorderWidthChanges&quot;];</div><div class="line">[self.view.layer addSublayer:myLayer];</div></pre></td></tr></table></figure></p>
<p>你也可以提供给路径给keyframeanimation，如 一个方块围着圆形路径旋转<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">CALayer *myLayer = [CALayer layer];</div><div class="line">myLayer.bounds = CGRectMake(0, 0, 100, 100);</div><div class="line">myLayer.backgroundColor = [UIColor redColor].CGColor;</div><div class="line"></div><div class="line">CAKeyframeAnimation *keyframeAnimation = [CAKeyframeAnimation animation];</div><div class="line">keyframeAnimation.keyPath = @&quot;position&quot;;</div><div class="line">CGRect boundingRect = CGRectMake(10, 100, 300, 300);</div><div class="line">keyframeAnimation.path = CFAutorelease(CGPathCreateWithEllipseInRect(boundingRect, NULL));//创建一个圆形路径</div><div class="line">keyframeAnimation.duration = 4;</div><div class="line">keyframeAnimation.repeatCount = HUGE_VALF;</div><div class="line">keyframeAnimation.calculationMode = kCAAnimationPaced;</div><div class="line"></div><div class="line">[myLayer addAnimation:keyframeAnimation forKey:@&quot;EllipseKeyframeAnimation&quot;];</div><div class="line"></div><div class="line">[self.view.layer addSublayer:myLayer];</div></pre></td></tr></table></figure></p>
<h4 id="执行一组动画"><a href="#执行一组动画" class="headerlink" title="执行一组动画"></a>执行一组动画</h4><p>如果你想执行对一个 layer 执行多个动画，那就要使用 CAAnimationGroup 对象,例如对一个 layer 既执行 <code>borderWidth</code> 改变又要改变 <code>borderColor</code>:     </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">// Animation 1</div><div class="line">CAKeyframeAnimation* widthAnim = [CAKeyframeAnimation animationWithKeyPath:@&quot;borderWidth&quot;];</div><div class="line">NSArray* widthValues = [NSArray arrayWithObjects:@1.0, @10.0, @5.0, @30.0, @0.5, @15.0, @2.0, @50.0, @0.0, nil];</div><div class="line">widthAnim.values = widthValues;</div><div class="line">widthAnim.calculationMode = kCAAnimationPaced;</div><div class="line"></div><div class="line">// Animation 2</div><div class="line">CAKeyframeAnimation* colorAnim = [CAKeyframeAnimation animationWithKeyPath:@&quot;borderColor&quot;];</div><div class="line">NSArray* colorValues = [NSArray arrayWithObjects:(id)[UIColor greenColor].CGColor,</div><div class="line">(id)[UIColor redColor].CGColor, (id)[UIColor blueColor].CGColor,  nil];</div><div class="line">colorAnim.values = colorValues;</div><div class="line">colorAnim.calculationMode = kCAAnimationPaced;</div><div class="line"></div><div class="line">// Animation group</div><div class="line">CAAnimationGroup* group = [CAAnimationGroup animation];</div><div class="line">group.animations = [NSArray arrayWithObjects:colorAnim, widthAnim, nil];</div><div class="line">group.duration = 5.0;</div><div class="line"></div><div class="line">[myLayer addAnimation:group forKey:@&quot;BorderChanges&quot;];</div></pre></td></tr></table></figure>
<h4 id="停止一个正在运行的明确动画"><a href="#停止一个正在运行的明确动画" class="headerlink" title="停止一个正在运行的明确动画"></a>停止一个正在运行的明确动画</h4><p>动画一般是完成时才停止，如果你要停止一个正在运行着的动画，你可以</p>
<p>调用 <code>removeAnimationForKey</code> 方法，key 是 <code>addAnimation: forKey</code> 时候的 key，他来指定动画唯一<br>如果想要 layer 上的所有动画，调用 <code>removeAllAnimation:</code> 方法</p>
<p>当你移除一个动画，Core Animation 通过使用当前值来重画 layer。因为当前值通常是动画的结束值，这样就会导致 layer 突然停止动画。如果你想让 layer 保持最后的动画 frame，你可以使用 layer 对象的展示树来获取最终值，然后赋给对象的 layer 树</p>
<h4 id="监测动画的起始状态"><a href="#监测动画的起始状态" class="headerlink" title="监测动画的起始状态"></a>监测动画的起始状态</h4><p>Core Animation 有两种不同的方式来通知动画状态。<br>1.使用 <code>setCompletionBlock:</code> 方法添加完成 block 到当前处理。当所有的动画处理完成是，这个处理执行你的完成 block<br>2.分配 delegate 到你的 CAAnimation 对象，实现 <code>animtaionDidStart:</code> 方法和 <code>animationDidStop: finished:</code> 协议方法  </p>
<h2 id="Core-Animation-类的继承关系图"><a href="#Core-Animation-类的继承关系图" class="headerlink" title="Core Animation 类的继承关系图"></a>Core Animation 类的继承关系图</h2><p><img src="/images/core_animation_guid/core_animation_guid_5.png" alt="Layer Subclass">  </p>
<p>参考文章：<br><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/CoreAnimation_guide/CreatingBasicAnimations/CreatingBasicAnimations.html#//apple_ref/doc/uid/TP40004514-CH3-SW1" target="_blank" rel="external">苹果官方文档 Core Animation Guid</a><br><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/CoreAnimation_guide/Key-ValueCodingExtensions/Key-ValueCodingExtensions.html" target="_blank" rel="external">苹果官方：KeyPath</a><br><a href="http://objccn.io/issue-12-1/" target="_blank" rel="external">动画解释</a><br><a href="http://blog.csdn.net/totogo2010/article/details/8604719" target="_blank" rel="external">Core Animation 之基础介绍</a>  </p>
</div></article></div></section><footer><div class="paginator"><a href="/2014/10/26/mian-shi-zi-ji/" class="prev">上一篇</a><a href="/2014/09/12/ru-he-ti-gao-ioskai-fa/" class="next">下一篇</a></div><div data-thread-key="2014/10/25/core-animation-xue-xi-zhi-lu/" data-title="Core Animation 学习之路" data-url="http://iYiming.me/2014/10/25/core-animation-xue-xi-zhi-lu/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"jiajiayouba"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>© 2014 - 2016 <a href="http://iYiming.me">iYiming</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1253468447'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s6.cnzz.com/z_stat.php%3Fid%3D1253468447%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script></body></html>