<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> iOS 图片调整技术 · 一鸣的博客</title><meta name="description" content="iOS 图片调整技术 - iYiming"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.jpg"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://iYiming.me/atom.xml" title="一鸣的博客"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.jpg"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/jiajiayouba" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/iYiming" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">iOS 图片调整技术</h1><div class="post-info">2015年7月12日</div><div class="post-content"><p>前几天看到<a href="http://nshipster.com/" target="_blank" rel="external">NSHisper</a>上的一篇关于图片缩放的文章挺好，到<a href="http://nshipster.cn/" target="_blank" rel="external">中文版</a>上找对应的中文版本看，没有找到。索性就自己翻译一下。下面是原文地址：</p>
<p><a href="http://nshipster.com/image-resizing/" target="_blank" rel="external">http://nshipster.com/image-resizing/</a></p>
<p>翻译如下：</p>
<p>自iOS出现以来，iOS开发者一直被一个问题所困扰：“如何调整一张图片”，在开发者和平台相互不信任的刺激下，这个问题变得含糊不清。在搜索出的一千条垃圾代码样例里，每一个<br>都自称是正确的答案，而其他的是假先知。</p>
<p>这是令人尴尬的，真的。</p>
<p>本周的文章努力对在iOS上调整图片的多种方式做出清晰解释（在OS X，需要一个UImage到NSImage适当的转换），用事实证明每种方式的性能特征，而不是简单的适用于所有情况的任何一种方式。</p>
<p><strong>在进一步阅读之前，请注意下面的这段话：</strong></p>
<blockquote>
<p>当设置UIImageView的Image， 对绝大多数的用例来手动调整图片是没有必要的。相反，可以简单的设置contentMode属性，无论是.ScaleAspectFit 来确保整个图片可以在UIImageView中都看得到，或者是设置.ScaleAspectFill，根据需要从中心来裁剪图片，来确保图片填充在UIImageView里。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;imageView.contentMode = .ScaleAspectFit </div><div class="line">&gt;imageView.image = image</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h2 id="确定缩放尺寸"><a href="#确定缩放尺寸" class="headerlink" title="确定缩放尺寸"></a>确定缩放尺寸</h2><p>在做图片调整之前，首先一个必须要决定的目标是要缩放的尺寸。</p>
<h4 id="0-通过系数缩放"><a href="#0-通过系数缩放" class="headerlink" title="0.通过系数缩放"></a>0.通过系数缩放</h4><p>缩放图片最简单的一种方式，是通过常量系数。通常，这个调用是除以一个整数，来减少原始尺寸（而不是乘以一个整数来放大）</p>
<p>新的尺寸可以通过单独缩放宽度和高度组件来计算。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let size = CGSize(width: image.size.width / 2, height: image.size.height / 2)  </div><div class="line"></div><div class="line">...或者通过运用CGAffineTransform:</div><div class="line">let size = CGSizeApplyAffineTransform(image.size, CGAffineTransformMakeScale(0.5, 0.5))</div></pre></td></tr></table></figure>
<h4 id="1-通过长宽比缩放"><a href="#1-通过长宽比缩放" class="headerlink" title="1.通过长宽比缩放"></a>1.通过长宽比缩放</h4><p>这样常常有用来缩放原始尺寸用这种方式，来适应一个矩形不用改变原始长宽比。AVFoundation框架中的AVMakeRectWithAspectRatioInsideRect是一个有用的函数，负责为你计算：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">import AVFoundation</div><div class="line">let rect = AVMakeRectWithAspectRatioInsideRect(image.size, imageView.bounds)</div></pre></td></tr></table></figure>
<h2 id="缩放图片"><a href="#缩放图片" class="headerlink" title="缩放图片"></a>缩放图片</h2><p>有许多不同的方式来缩放图片，每一种具有不同的能力和性能特征</p>
<h4 id="0-UIGraphicsBeginImageContextWithOptions-amp-UIImage-drawInRect"><a href="#0-UIGraphicsBeginImageContextWithOptions-amp-UIImage-drawInRect" class="headerlink" title="0.UIGraphicsBeginImageContextWithOptions &amp; UIImage -drawInRect:"></a>0.UIGraphicsBeginImageContextWithOptions &amp; UIImage -drawInRect:</h4><p>在UIKIt框架中可以发现高级的图片调整API。提供一个UIImage对象，一个临时图形上下文，用来渲染一个缩放版本，使用UIGraphicBeginImageContextWithOptions() 和 UIGraphicsGetImageFromCurrentImageContext():</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">let image = UIImage(contentsOfFile: self.URL.absoluteString!)</div><div class="line"></div><div class="line">let size = CGSizeApplyAffineTransform(image.size, CGAffineTransformMakeScale(0.5, 0.5))</div><div class="line">let hasAlpha = false</div><div class="line">let scale: CGFloat = 0.0 // Automatically use scale factor of main screen</div><div class="line"></div><div class="line">UIGraphicsBeginImageContextWithOptions(size, !hasAlpha, scale)</div><div class="line">image.drawInRect(CGRect(origin: CGPointZero, size: size))</div><div class="line"></div><div class="line">let scaledImage = UIGraphicsGetImageFromCurrentImageContext()</div><div class="line">UIGraphicsEndImageContext()</div></pre></td></tr></table></figure>
<p>UIGraphicsBeginImageContextWithOptions()创建一个临时渲染上下文，在这上面绘制原始图片。第一个参数，size，是缩放图片的尺寸，第二个参数，isOpaque 是用来决定透明通道是否被渲染。对没有透明度的图片设置这个参数为false，可能导致图片有粉红色调。第三个参数scale是显示缩放系数。当设置成0.0，主屏幕的缩放系数将被使用，对视网膜屏显示是2.0或者更高（在iPhone6 Plus 上是 3.0）</p>
<h4 id="1-CGBitmapContextCreate-amp-CGContextDrawImage"><a href="#1-CGBitmapContextCreate-amp-CGContextDrawImage" class="headerlink" title="1.CGBitmapContextCreate &amp; CGContextDrawImage"></a>1.CGBitmapContextCreate &amp; CGContextDrawImage</h4><p>Core Graphic/Quartz 2D 提供了一个底层的API集合，可以提供更高级的配置。提供一个CGImage对象，一个临时位图上下文，用来渲染缩放的图片，使用CGBitmapContextCreate()和CGBitmapContextCreateImage():</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">let cgImage = UIImage(contentsOfFile: self.URL.absoluteString!).CGImage</div><div class="line"></div><div class="line">let width = CGImageGetWidth(cgImage) / 2</div><div class="line">let height = CGImageGetHeight(cgImage) / 2</div><div class="line">let bitsPerComponent = CGImageGetBitsPerComponent(cgImage)</div><div class="line">let bytesPerRow = CGImageGetBytesPerRow(cgImage)</div><div class="line">let colorSpace = CGImageGetColorSpace(cgImage)</div><div class="line">let bitmapInfo = CGImageGetBitmapInfo(cgImage)</div><div class="line"></div><div class="line">let context = CGBitmapContextCreate(nil, width, height, bitsPerComponent, bytesPerRow, colorSpace, bitmapInfo.rawValue)</div><div class="line"></div><div class="line">CGContextSetInterpolationQuality(context, kCGInterpolationHigh)</div><div class="line"></div><div class="line">CGContextDrawImage(context, CGRect(origin: CGPointZero, size: CGSize(width: CGFloat(width), height: CGFloat(height))), cgImage)</div><div class="line"></div><div class="line">let scaledImage = CGBitmapContextCreateImage(context).flatMap &#123; UIImage(CGImage: $0 &#125;</div></pre></td></tr></table></figure>
<p>CGBitmapContextCreate需要几个参数来构建上下文，期望的尺寸和每个给定色彩空间内部的信道。在这个例子中，这些值从 CGImage中获取。下一步，CGContextSetInterpolationQuality允许上下文在各个保真度等级插入像素。在这个例子中，传递kCGInterpolationHigh参数用来获得最优的结果。CGContextDrawImage允许在制定的尺寸和位置上画图，允许在特定边缘或者适应一组图片特征比如faces，裁剪图片。最终，CGBitmapContextCreateImage从上下文中创建CGImage</p>
<h4 id="2-CGImageSourceCreateThumbnailAtIndex"><a href="#2-CGImageSourceCreateThumbnailAtIndex" class="headerlink" title="2.CGImageSourceCreateThumbnailAtIndex"></a>2.CGImageSourceCreateThumbnailAtIndex</h4><p>Image I/O是一个强大，也是一个很少知道可以用来处理图片的框架。依赖Core Graphic，它可以在许多不同格式下读写，访问图片媒体，执行通用图片处理。在这个平台上框架提供了快速编解码图片，高级缓存机制和快速加载图片能力。</p>
<p>CGImageSourceCreateThumbnailtIndex提供了一个简介的AP,比同样的Core Graphics调用有不同的选项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">import ImageIO</div><div class="line"></div><div class="line">if let imageSource = CGImageSourceCreateWithURL(self.URL, nil) &#123;</div><div class="line">    let options: CFDictionary = [</div><div class="line">        kCGImageSourceThumbnailMaxPixelSize: max(size.width, size.height) / 2.0,</div><div class="line">        kCGImageSourceCreateThumbnailFromImageIfAbsent: true</div><div class="line">    ]</div><div class="line"></div><div class="line">    let scaledImage = CGImageSourceCreateThumbnailAtIndex(imageSource, 0, options).flatMap &#123; UIImage(CGImage: $0) &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>提供了CGImageSource和一组选项，CGImageSourceCreateThumbnailAtIndex创建一个缩略图。调整是通过kCGImageSourceThumbnailMaxPixelSize完成。指定最大的尺寸初一一个常量系数来缩放图片，同时保持原始的长宽比。通过指定不论是kCGImageSourceCreateThumbnailFromImageIfAbsent 或者 kCGImageSourceCreateThumbnailFromImageAlways，后续调用，Image I/O将自动缓存缩放的结果。</p>
<h4 id="3-Core-Image-Lanczos-采样"><a href="#3-Core-Image-Lanczos-采样" class="headerlink" title="3.Core Image Lanczos 采样"></a>3.Core Image Lanczos 采样</h4><p>Core Image 提供一个使用CILanczosScaleTransform滤镜内置的Lanczos 采样函数。虽然是比UIKit更高级的API，在Core Image普及的使用KVC，使他用起来比较笨拙。</p>
<p>这就是说，设计模式是一致的。创建变换滤镜，配置和渲染输出图片的过程就像是其他Core Image流程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">let image = CIImage(contentsOfURL: self.URL)</div><div class="line"></div><div class="line">let filter = CIFilter(name: &quot;CILanczosScaleTransform&quot;)</div><div class="line">filter.setValue(image, forKey: &quot;inputImage&quot;)</div><div class="line">filter.setValue(0.5, forKey: &quot;inputScale&quot;)</div><div class="line">filter.setValue(1.0, forKey: &quot;inputAspectRatio&quot;)</div><div class="line">let outputImage = filter.valueForKey(&quot;outputImage&quot;) as CIImage</div><div class="line"></div><div class="line">let context = CIContext(options: nil)</div><div class="line">let scaledImage = UIImage(CGImage: self.context.createCGImage(outputImage, fromRect: outputImage.extent()))</div></pre></td></tr></table></figure>
<p>CILanczosScaleTransform接受inputImage，InputScale，和inputAspectRatio，所有的这些不言自明。CIContext通过CGImageRef间接表示方式，被用来创建UIImage，既然UIImage（CIImage:）不像预期那样经常工作。</p>
<h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><p>那么，如何让这些不同途径组合成另一个？</p>
<p>这里有一组在运行iOS 8.0GM的iPod Touch(第五代)性能测试结果，使用XCTestCase.measureBlock():</p>
<h4 id="JPEG"><a href="#JPEG" class="headerlink" title="JPEG"></a>JPEG</h4><p>缩放一个来自NASA Visible Earth，大的，高分辨率（12000 * 12000 px 20 MB JPEG）原图片。</p>
<p><img src="/images/image-resizing/1.png" alt="1.png"><br>￼</p>
<h4 id="PNG"><a href="#PNG" class="headerlink" title="PNG"></a>PNG</h4><p>缩放一个相当大（1024 * 1024 px 1MB PNG）来渲染，即Postgres.app的应用Icon 所方程成0.1倍尺寸：</p>
<p><img src="/images/image-resizing/2.png" alt="2.png"></p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><blockquote>
<p>UIKit,Core Graphic 和Image I/O 对大多数图片缩放操作表现良好</p>
<p>Core Image优于图片缩放操作。实际上，在这篇文章里特别推荐使用Core Graphic或者 Image I/O<br>函数来对图片缩放或者原先采样</p>
<p>对不需要额外功能的一般图片缩放，UIGraphicsBiginImageContextWithOptions可能是最好的选项</p>
<p>如果图片质量是一个考虑，考虑使用CGBitmapContextCreate与CGContextSetInterpolationQuality组合方式</p>
<p>当以显示缩略图为目的的缩放图片，CGImageSourceCreateThumbnailAtIndex提供了一个对图片渲染和缓存的完整解决方式</p>
</blockquote>
<p>注明：  </p>
<p>第一次翻译整篇文章，有些地方，翻译的有点粗糙，不明白的地方请<a href="http://nshipster.com/" target="_blank" rel="external">参照原文</a>。</p>
</div></article></div></section><footer><div class="paginator"><a href="/2015/07/17/du-chu-shi-jian/" class="prev">上一篇</a><a href="/2015/07/09/xcode-cha-jian-bu-neng-shi-yong-wen-ti/" class="next">下一篇</a></div><div data-thread-key="2015/07/12/ios-tu-pian-diao-zheng-ji-zhu/" data-title="iOS 图片调整技术" data-url="http://iYiming.me/2015/07/12/ios-tu-pian-diao-zheng-ji-zhu/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"jiajiayouba"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>© 2014 - 2016 <a href="http://iYiming.me">iYiming</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1253468447'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s6.cnzz.com/z_stat.php%3Fid%3D1253468447%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script></body></html>