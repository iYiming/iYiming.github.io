<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> iOS 图片缩放 · 一鸣的博客</title><meta name="description" content="iOS 图片缩放 - iYiming"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.jpg"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://iYiming.me/atom.xml" title="一鸣的博客"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.jpg"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/jiajiayouba" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/iYiming" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">iOS 图片缩放</h1><div class="post-info">2015年7月12日</div><div class="post-content"><p>前几天在 <a href="http://nshipster.com/" target="_blank" rel="external">NSHisper</a> 上看到一篇关于图片缩放的文章，感觉不错，到<a href="http://nshipster.cn/" target="_blank" rel="external">中文版</a>上没有找到对应的中文版本。索性就翻译了一下。下面是原文地址：</p>
<p><a href="http://nshipster.com/image-resizing/" target="_blank" rel="external">http://nshipster.com/image-resizing/</a></p>
<a id="more"></a>
<p>翻译如下：</p>
<p>自 iOS 出现以来，iOS 开发者一直被一个问题所困扰：“如何调整一张图片”。在开发者和平台相互不信任的刺激下，这个问题变得含糊不清。在搜索出的一千条垃圾代码样例里，每一个<br>都自称是正确的答案，而其他的是假先知。</p>
<p>这是令人尴尬的，真的。</p>
<p>本周的文章努力对在 iOS 上调整图片的多种方式做出清晰解释（在 OS X，需要一个  <code>UImage</code> 到 <code>NSImage</code> 适当的转换），用事实证明每种方式的性能特征，而不是简单的适用于所有情况的任何一种方式。</p>
<p><strong>在进一步阅读之前，请注意下面的这段话：</strong></p>
<blockquote>
<p>当设置 <code>UIImageView</code> 的 <code>image</code> ， 对绝大多数的用例来手动调整图片是没有必要的。相反，可以简单的设置 <code>contentMode</code> 属性，无论是 <code>.ScaleAspectFit</code> 来确保整个图片可以在 <code>UIImageView</code> 中都看得到，或者是设置 <code>.ScaleAspectFill</code> ，根据需要从中心来裁剪图片，来确保图片填充在 <code>UIImageView</code>里。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">imageView.contentMode = .<span class="type">ScaleAspectFit</span> </div><div class="line">imageView.image = image</div></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="确定缩放尺寸"><a href="#确定缩放尺寸" class="headerlink" title="确定缩放尺寸"></a>确定缩放尺寸</h2><p>在做图片调整之前，首先一个必须要决定的目标是要缩放的尺寸。</p>
<h4 id="通过系数缩放"><a href="#通过系数缩放" class="headerlink" title="通过系数缩放"></a>通过系数缩放</h4><p>缩放图片最简单的一种方式，是通过常量系数。通常，这个调用是除以一个整数，来减少原始尺寸（而不是乘以一个整数来放大）</p>
<p>新的尺寸可以通过单独缩放宽度和高度组件来计算。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> size = <span class="type">CGSize</span>(width: image.size.width / <span class="number">2</span>, height: image.size.height / <span class="number">2</span>)  </div><div class="line"></div><div class="line">...或者通过运用<span class="type">CGAffineTransform</span>:</div><div class="line"><span class="keyword">let</span> size = <span class="type">CGSizeApplyAffineTransform</span>(image.size, <span class="type">CGAffineTransformMakeScale</span>(<span class="number">0.5</span>, <span class="number">0.5</span>))</div></pre></td></tr></table></figure>
<h4 id="通过长宽比缩放"><a href="#通过长宽比缩放" class="headerlink" title="通过长宽比缩放"></a>通过长宽比缩放</h4><p>这样常常有用来缩放原始尺寸用这种方式，来适应一个矩形不用改变原始长宽比。 AVFoundation 框架中的 <code>AVMakeRectWithAspectRatioInsideRect</code> 是一个有用的函数，负责为你计算：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> AVFoundation</div><div class="line"><span class="keyword">let</span> rect = <span class="type">AVMakeRectWithAspectRatioInsideRect</span>(image.size, imageView.bounds)</div></pre></td></tr></table></figure>
<h2 id="缩放图片"><a href="#缩放图片" class="headerlink" title="缩放图片"></a>缩放图片</h2><p>有许多不同的方式来缩放图片，每一种具有不同的能力和性能特征</p>
<h4 id="UIGraphicsBeginImageContextWithOptions-amp-UIImage-drawInRect"><a href="#UIGraphicsBeginImageContextWithOptions-amp-UIImage-drawInRect" class="headerlink" title="UIGraphicsBeginImageContextWithOptions &amp; UIImage -drawInRect:"></a>UIGraphicsBeginImageContextWithOptions &amp; UIImage -drawInRect:</h4><p>在 UIKit 框架中可以发现高级的图片调整 API。提供一个 <code>UIImage</code> 对象，一个临时图形上下文，用来渲染一个缩放版本，使用 <code>UIGraphicBeginImageContextWithOptions()</code> 和 <code>UIGraphicsGetImageFromCurrentImageContext()</code> :</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> image = <span class="type">UIImage</span>(contentsOfFile: <span class="keyword">self</span>.<span class="type">URL</span>.absoluteString!)</div><div class="line"></div><div class="line"><span class="keyword">let</span> size = <span class="type">CGSizeApplyAffineTransform</span>(image.size, <span class="type">CGAffineTransformMakeScale</span>(<span class="number">0.5</span>, <span class="number">0.5</span>))</div><div class="line"><span class="keyword">let</span> hasAlpha = <span class="literal">false</span></div><div class="line"><span class="keyword">let</span> scale: <span class="type">CGFloat</span> = <span class="number">0.0</span> <span class="comment">// Automatically use scale factor of main screen</span></div><div class="line"></div><div class="line"><span class="type">UIGraphicsBeginImageContextWithOptions</span>(size, !hasAlpha, scale)</div><div class="line">image.drawInRect(<span class="type">CGRect</span>(origin: <span class="type">CGPointZero</span>, size: size))</div><div class="line"></div><div class="line"><span class="keyword">let</span> scaledImage = <span class="type">UIGraphicsGetImageFromCurrentImageContext</span>()</div><div class="line"><span class="type">UIGraphicsEndImageContext</span>()</div></pre></td></tr></table></figure>
<p><code>UIGraphicsBeginImageContextWithOptions()</code> 创建一个临时渲染上下文，在这上面绘制原始图片。第 1 个参数 <code>size</code> 是缩放图片的尺寸，第 2 个参数 <code>isOpaque</code> 是用来决定透明通道是否被渲染。对没有透明度的图片设置这个参数为 <code>false</code>，可能导致图片有粉红色调。第 3 个参数 <code>scale</code> 是显示缩放系数。当设置成 <code>0.0</code>，主屏幕的缩放系数将被使用，对视网膜屏显示是 <code>2.0</code> 或者更高（在 iPhone 6 Plus 上是 <code>3.0</code>）</p>
<h4 id="CGBitmapContextCreate-amp-CGContextDrawImage"><a href="#CGBitmapContextCreate-amp-CGContextDrawImage" class="headerlink" title="CGBitmapContextCreate &amp; CGContextDrawImage"></a>CGBitmapContextCreate &amp; CGContextDrawImage</h4><p>Core Graphic/Quartz 2D 提供了一个底层的 API 集合，可以提供更高级的配置。提供一个 <code>CGImage</code> 对象，一个临时位图上下文，用来渲染缩放的图片，使用 <code>CGBitmapContextCreate()</code> 和 <code>CGBitmapContextCreateImage()</code>:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> cgImage = <span class="type">UIImage</span>(contentsOfFile: <span class="keyword">self</span>.<span class="type">URL</span>.absoluteString!).<span class="type">CGImage</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> width = <span class="type">CGImageGetWidth</span>(cgImage) / <span class="number">2</span></div><div class="line"><span class="keyword">let</span> height = <span class="type">CGImageGetHeight</span>(cgImage) / <span class="number">2</span></div><div class="line"><span class="keyword">let</span> bitsPerComponent = <span class="type">CGImageGetBitsPerComponent</span>(cgImage)</div><div class="line"><span class="keyword">let</span> bytesPerRow = <span class="type">CGImageGetBytesPerRow</span>(cgImage)</div><div class="line"><span class="keyword">let</span> colorSpace = <span class="type">CGImageGetColorSpace</span>(cgImage)</div><div class="line"><span class="keyword">let</span> bitmapInfo = <span class="type">CGImageGetBitmapInfo</span>(cgImage)</div><div class="line"></div><div class="line"><span class="keyword">let</span> context = <span class="type">CGBitmapContextCreate</span>(<span class="literal">nil</span>, width, height, bitsPerComponent, bytesPerRow, colorSpace, bitmapInfo.rawValue)</div><div class="line"></div><div class="line"><span class="type">CGContextSetInterpolationQuality</span>(context, kCGInterpolationHigh)</div><div class="line"></div><div class="line"><span class="type">CGContextDrawImage</span>(context, <span class="type">CGRect</span>(origin: <span class="type">CGPointZero</span>, size: <span class="type">CGSize</span>(width: <span class="type">CGFloat</span>(width), height: <span class="type">CGFloat</span>(height))), cgImage)</div><div class="line"></div><div class="line"><span class="keyword">let</span> scaledImage = <span class="type">CGBitmapContextCreateImage</span>(context).flatMap &#123; <span class="type">UIImage</span>(<span class="type">CGImage</span>: $<span class="number">0</span> &#125;</div></pre></td></tr></table></figure>
<p><code>CGBitmapContextCreate</code> 需要几个参数来构建上下文，期望的尺寸和每个给定色彩空间内部的信道。在这个例子中，这些值从 <code>CGImage</code> 中获取。下一步， <code>CGContextSetInterpolationQuality</code> 允许上下文在各个保真度等级插入像素。在这个例子中，传递 <code>kCGInterpolationHigh</code> 参数用来获得最优的结果。 <code>CGContextDrawImage</code> 允许在制定的尺寸和位置上画图，允许在特定边缘或者适应一组图片特征比如 faces，裁剪图片。最终，<code>CGBitmapContextCreateImage</code> 从上下文中创建 <code>CGImage</code> 。</p>
<h4 id="CGImageSourceCreateThumbnailAtIndex"><a href="#CGImageSourceCreateThumbnailAtIndex" class="headerlink" title="CGImageSourceCreateThumbnailAtIndex"></a>CGImageSourceCreateThumbnailAtIndex</h4><p>Image I/O 是一个强大，也是一个很少知道可以用来处理图片的框架。依赖 Core Graphic，它可以在许多不同格式下读写，访问图片媒体，执行通用图片处理。在这个平台上框架提供了快速编解码图片，高级缓存机制和快速加载图片能力。</p>
<p><code>CGImageSourceCreateThumbnailtIndex</code> 提供了一个简介的 API,比同样的 Core Graphics 调用有不同的选项：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> ImageIO</div><div class="line"></div><div class="line"><span class="keyword">if</span> <span class="keyword">let</span> imageSource = <span class="type">CGImageSourceCreateWithURL</span>(<span class="keyword">self</span>.<span class="type">URL</span>, <span class="literal">nil</span>) &#123;</div><div class="line">    <span class="keyword">let</span> options: <span class="type">CFDictionary</span> = [</div><div class="line">        kCGImageSourceThumbnailMaxPixelSize: <span class="built_in">max</span>(size.width, size.height) / <span class="number">2.0</span>,</div><div class="line">        kCGImageSourceCreateThumbnailFromImageIfAbsent: <span class="literal">true</span></div><div class="line">    ]</div><div class="line"></div><div class="line">    <span class="keyword">let</span> scaledImage = <span class="type">CGImageSourceCreateThumbnailAtIndex</span>(imageSource, <span class="number">0</span>, options).flatMap &#123; <span class="type">UIImage</span>(<span class="type">CGImage</span>: $<span class="number">0</span>) &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>提供了 <code>CGImageSource</code> 和一组选项 <code>CGImageSourceCreateThumbnailAtIndex</code> 创建一个缩略图。调整是通过 <code>kCGImageSourceThumbnailMaxPixelSize</code> 完成。指定最大的尺寸初一一个常量系数来缩放图片，同时保持原始的长宽比。通过指定不论是 <code>kCGImageSourceCreateThumbnailFromImageIfAbsent</code> 或者 <code>kCGImageSourceCreateThumbnailFromImageAlways</code> ，后续调用，Image I/O 将自动缓存缩放的结果。</p>
<h4 id="Core-Image-Lanczos-采样"><a href="#Core-Image-Lanczos-采样" class="headerlink" title="Core Image Lanczos 采样"></a>Core Image Lanczos 采样</h4><p>Core Image 提供一个使用 <code>CILanczosScaleTransform</code> 滤镜内置的 Lanczos 采样函数。虽然是比 UIKit 更高级的 API，在 Core Image 普及的使用 KVC ，使他用起来比较笨拙。</p>
<p>这就是说，设计模式是一致的。创建变换滤镜，配置和渲染输出图片的过程就像是其他 Core Image 流程：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> image = <span class="type">CIImage</span>(contentsOfURL: <span class="keyword">self</span>.<span class="type">URL</span>)</div><div class="line"></div><div class="line"><span class="keyword">let</span> <span class="built_in">filter</span> = <span class="type">CIFilter</span>(name: <span class="string">"CILanczosScaleTransform"</span>)</div><div class="line"><span class="built_in">filter</span>.setValue(image, forKey: <span class="string">"inputImage"</span>)</div><div class="line"><span class="built_in">filter</span>.setValue(<span class="number">0.5</span>, forKey: <span class="string">"inputScale"</span>)</div><div class="line"><span class="built_in">filter</span>.setValue(<span class="number">1.0</span>, forKey: <span class="string">"inputAspectRatio"</span>)</div><div class="line"><span class="keyword">let</span> outputImage = <span class="built_in">filter</span>.valueForKey(<span class="string">"outputImage"</span>) <span class="keyword">as</span> <span class="type">CIImage</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> context = <span class="type">CIContext</span>(options: <span class="literal">nil</span>)</div><div class="line"><span class="keyword">let</span> scaledImage = <span class="type">UIImage</span>(<span class="type">CGImage</span>: <span class="keyword">self</span>.context.createCGImage(outputImage, fromRect: outputImage.extent()))</div></pre></td></tr></table></figure>
<p><code>CILanczosScaleTransform</code> 接受 <code>inputImage</code>，<code>InputScale</code>，和<code>inputAspectRatio</code>，所有的这些不言自明。<code>CIContext</code> 通过 <code>CGImageRef</code> 间接表示方式，被用来创建 <code>UIImage</code>，既然 <code>UIImage</code>（ <code>CIImage</code> ）不像预期那样经常工作。</p>
<h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><p>那么，如何让这些不同途径组合成另一个？</p>
<p>这里有一组在运行 iOS 8.0 GM 的 iPod Touch (第五代)性能测试结果，使用 <code>XCTestCase.measureBlock()</code> :</p>
<h4 id="JPEG"><a href="#JPEG" class="headerlink" title="JPEG"></a>JPEG</h4><p>缩放一个来自 NASA Visible Earth ，大的，高分辨率（ 12000 * 12000 px 20 MB JPEG ）原图片。</p>
<p><img src="/images/image-resizing/1.png" alt="1.png"><br>￼</p>
<h4 id="PNG"><a href="#PNG" class="headerlink" title="PNG"></a>PNG</h4><p>缩放一个相当大（ 1024 * 1024 px 1MB PNG ）来渲染，即 Postgres.app 的应用 Icon 所方程成 0.1 倍尺寸：</p>
<p><img src="/images/image-resizing/2.png" alt="2.png"></p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><blockquote>
<p>UIKit,Core Graphic 和 Image I/O 对大多数图片缩放操作表现良好</p>
<p>Core Image 优于图片缩放操作。实际上，在这篇文章里特别推荐使用 Core Graphic 或者 Image I/O 函数来对图片缩放或者原先采样</p>
<p>对不需要额外功能的一般图片缩放，<code>UIGraphicsBiginImageContextWithOptions</code> 可能是最好的选项</p>
<p>如果图片质量是一个考虑，考虑使用 <code>CGBitmapContextCreate</code> 与 <code>CGContextSetInterpolationQuality</code> 组合方式</p>
<p>当以显示缩略图为目的的缩放图片，<code>CGImageSourceCreateThumbnailAtIndex</code> 提供了一个对图片渲染和缓存的完整解决方式</p>
</blockquote>
</div></article></div></section><footer><div class="paginator"><a href="/2015/07/17/du-chu-shi-jian/" class="prev">上一篇</a><a href="/2015/07/09/xcode-cha-jian-bu-neng-shi-yong-wen-ti/" class="next">下一篇</a></div><div data-thread-key="2015/07/12/ios-tu-pian-diao-zheng-ji-zhu/" data-title="iOS 图片缩放" data-url="http://iYiming.me/2015/07/12/ios-tu-pian-diao-zheng-ji-zhu/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"jiajiayouba"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>© 2014 - 2016 <a href="http://iYiming.me">iYiming</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1253468447'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s6.cnzz.com/z_stat.php%3Fid%3D1253468447%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "//hm.baidu.com/hm.js?3cec0b24b46b86302d1aa3b050d4668f";var s = document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm, s);})();</script></body></html>