---
layout: post
title: "Run Loops"
date: 2015-01-03 22:38:01 +0800
comments: true
categories: iOS
---

经常碰到这个词，平常又很少用到，对此模棱两可，遂整理下。

根据苹果官方文档，总结如下：

>Run Loops的目的是当有活要干的时候就开始干，没活干的时候就睡大觉。

>NSRunloop对象处理的是输入源，如窗体上的键盘输入事件，NSPort对象，NSConnection对象等。NSRunLoop对象同样处理NSTimer事件。NSTimer不是一个真正意义上的输入源，它是一个特殊的类型，当NSTimer对象解除时，不会使NSRunLoop返回。

>不需要直接创建或显示的管理NSRunloop对象，所有的线程包括主线程，NSRunloop对象已经自动创建好了。如果需要访问当前线程的Run Loop，直接使用[NSRunloop currentRunloop]就OK啦！

##什么时候使用NSRunLoop对象
前提是在除主线程外的次级线程中（主线程默认已经自动开启了）  

###0.NSPort对象  

备注：这个不是很熟悉，[详见AFNetworking源码](https://github.com/AFNetworking/AFNetworking/blob/master/AFNetworking/AFURLConnectionOperation.m)
```
NSRunLoop *runLoop = [NSRunLoop currentRunLoop];
[runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];
[runLoop run];
```

###1.线程间交互

举个栗子，在自定义异步线程里中使用NSURLConnection
```
//异步
NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(download) object:nil];
[thread start];

//下载数据
- (void) download
{ 
    @autoreleasepool {
        NSURLRequest *request = [NSURLRequest requestWithURL:[NSURL URLWithString:@"http://www.sinaimg.cn/dy/slidenews/4_img/2014_50/704_1502763_259801.jpg"]];
        connection = [[NSURLConnection alloc] initWithRequest:request delegate:self];
        [connection scheduleInRunLoop:[NSRunLoop currentRunLoop] forMode:NSRunLoopCommonModes];
        [connection start];
        [[NSRunLoop currentRunLoop] run];
    }
}  

#pragma mark -
#pragma mark - NSURLConnectionDataDelegate
- (void) connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response
{
    NSLog(@"接收响应");
}

- (void) connection:(NSURLConnection *)connection didReceiveData:(NSData *)data
{
    NSLog(@"接收数据...");
}

- (void) connectionDidFinishLoading:(NSURLConnection *)connection
{
    NSLog(@"完成");
}

```

###2.NSTimer对象

```
//异步
NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(myTimer) object:nil];
[thread start];

- (void) myTimer
{
    NSTimer *myTimer = [NSTimer timerWithTimeInterval:3 target:self selector:@selector(executeMyTimer) userInfo:nil repeats:NO];

    [[NSRunLoop currentRunLoop] addTimer:myTimer forMode:NSDefaultRunLoopMode];
    [[NSRunLoop currentRunLoop] run];
}

- (void) executeMyTimer
{
    NSLog(@"我的Timer执行啦");
}
```

参考文章

[苹果官方文档1](https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW1)  
[苹果官方文档2](https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSRunLoop_Class/index.html#//apple_ref/doc/uid/TP40003725)  
[自己调研的一些关于NSRunLoop与NSTimer的知识](http://blog.csdn.net/ioswyl88219/article/details/16996531)