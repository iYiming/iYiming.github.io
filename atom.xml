<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>一鸣的博客</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://iYiming.me/"/>
  <updated>2016-08-14T13:57:23.000Z</updated>
  <id>http://iYiming.me/</id>
  
  <author>
    <name>iYiming</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>读 《设计中的设计》</title>
    <link href="http://iYiming.me/2016/08/09/2016-08-09-du-she-ji-zhong-de-she-ji/"/>
    <id>http://iYiming.me/2016/08/09/2016-08-09-du-she-ji-zhong-de-she-ji/</id>
    <published>2016-08-09T05:46:20.000Z</published>
    <updated>2016-08-14T13:57:23.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/du-she-ji-zhong-de-she-ji/0.jpg" alt="">  </p>
<p>好吧，终于开始写读书笔记了。种种借口，一言难尽。单提到原研哉，可能不知道是谁，甚至感觉这名字奇怪，但是提到无印良品，无人不晓吧。无印良品艺术总监就是原研哉。</p>
<a id="more"></a>
<p>先不管鸡的事，先来尝尝蛋。翻开书，书本的纸张、排版设计、配图等会美得吓你一跳，没舍得用笔划，读到有感觉的地方，会抄在打印纸上，以至于阅读的效率低下，一笔一画，恭恭敬敬，全当修复提笔忘字的 Bug 吧。写写停停，再整理成现在的电子版，花儿都开了。</p>
<p>从设计的历史到日常用品的再设计，从五感领域考虑设计到无中生有，从对消费欲望的引导到日本中的自己，再到最后的回归自然。看似循序渐进，但在一开始读的时候，混混沌沌，甚至有时读到无味想跳过。闲言不讲，来聊聊书里面的内容。</p>
<p>为何会产生现代设计呢？工业革命为经济带来了活力，初期的机械程度的落后使得产品的造型不够美感，导致有部分人产生了不满，他们奔走相告，从而产生了现代设计。详细说就是工业革命带来的粗糙丑陋的产品，让约翰·拉斯金和威廉·莫里斯这两个人看不下去了，那就开始革（zao）命（fan）吧，提出了一些想法。中间冒出一个叫包豪斯的德国人，他成了这场革命对象的集大成者。后来乌尔姆设计学院成了包豪斯的继承者（它的校长马克斯·比尔是包豪斯的最后一届学生），学校培养了些花花草草，后来为躲避战争，这些花花草草逃亡到美国，进而带向了全世界。书中还提到立体派、直线派、未来派、达达主义、新构成主义、造型主义、绝对主义、现代主义后现代主义什么的。坦白讲，除了苹果派和马克思主义，我真的搞不清这些都是什么。</p>
<p>如果让你去设计一件日常用品，你会怎么设计？生活里看到太多太多不好的设计：不能同时插两个设备的插座，不知是推还是平移的门，迈不开腿的阶梯，乱如麻的遥控器，丑陋难用的汽车导航仪等等等等。如果这些东西让自己设计，又该如何下手呢？</p>
<p>书里告诉了一个思路：</p>
<blockquote>
<p>如果能够现将已知的事物陌生化，然后再尝试挑战其真实性，才有可能深入了解它。  </p>
<p>再次设计，其内在追求在于回到原点，重新审视我们周围的设计，以最为平易近人的方式，来探索设计的本质。从无到有当然是创造；但将已知的事物陌生化，更是一种创造。</p>
</blockquote>
<p>作者分享了一次设计展（”REDESIGN —— 21 世纪日常用品再设计” 展）里面的作品，通过例子来看看设计师如何思考问题。这里引用下作者对其的描述：</p>
<blockquote>
<p>REDESIGN 展是以重新审视已经存在的日常用品为目的的设计展览，目的并不在于借各个优秀设计师只收来改良其原先的设计。说到底，这是一个提案展。日常用品是一个经过时间的淘洗、千锤百炼而成的成熟设计群，这是一个当代设计师很感兴趣但短时间内无法取得超越性成果的设计对象。另外，所有的设计提案中都有一个明确的设计理念，在想法上与原来的设计有着相当明显的差异。应该说，正是这些差异，才体现出了设计师所致力于表现的概念，无疑，这是真正值得我们重视的部分。所以，这个展览的真正目的是在差异中发现设计的意义。</p>
</blockquote>
<p>在这次设计展里，原研哉列出了一部分设计。考虑到空间和节约的卫生纸，会说话的出入境章，建筑体的捕蟑盒，落叶归根的火柴，有尊严的成年尿不湿以及下意识感的两款式的茶包。我最喜欢火柴和那个出入境章。</p>
<p>人通过视觉、听觉、触觉、嗅觉、味觉来感知外界。设计本质就是信息传递。如何让这五感充分体现在设计里，原研哉用信息建筑的思维方式更深一步的思考问题。长野冬季奥运会的节目册的踏雪设计、用布制作的妇产医院标识系统体现出柔和、干净感、松屋银座的二次设计里包含了具有巨型拉链的关联性触觉设计、购物袋的触感设计等。将多种感觉融合到设计里，是一件很复杂的事，原研哉只介绍了触觉、视觉，其他感觉并未介绍，我也在想是否有融合这五种感知的设计？平常喝的可口可乐算不算？</p>
<p>说完五感，原研哉的境界再一次提升，到了无中生有的境界，说实话这里太哲学，由于资质原因，没搞明白啥是无中生有。不过这个地平线的图挺漂亮，就是感觉很美，说不出来为啥美。以后我或许能懂吧。</p>
<p>如何对消费欲望引导，这个是比较实际的问题，提到了精准的市场调研，举了日本车和欧美车的对比，各有优劣，日本车实用，欧美车设计漂亮。还提到日本人的住宅方式。提到这些也没总结出如何对消费欲望进行引导，萝卜白菜各有所爱，最后总结出提高文化，在适应市场的同时，用心推动消费者的审美意识。这是一个发散性的问题，没有固定的答案。</p>
<p>在日本的原研哉，造访一百多个城市，这里有雅叙苑与天空森林，有小布施堂和一家无何有的旅馆。中间提到一本百年前的书《阴翳礼赞》。</p>
<p>读一本书，识一个人，我顺着蛋找着了一个养鸡场。深泽直人、田中一光、面出薰 …</p>
<p>一些其它思考：</p>
<p>何为读书笔记？自己理解的读书笔记，就是记录读书过程中感觉有道理、结合自身感受所写出来的文字记录。如果不小心被被别人看见了，对，说的就是你！那你半信半疑就好。</p>
<p>如果扔掉书本写篇读书笔记，想必会漏掉一大半，其实写出的一大半才是真正得到的。下次可以尝试扔掉书本写读书笔记，然后对照书再补充一遍，这样收获会更大些。</p>
<p>书本中有些问题没有给出答案，只是顺着作者自己的思考，一点点的靠近答案。</p>
<p>作为一名移动开发者，我不会太在意技术上的实现，相反我会更在意好不好用，界面、交互设计的如何，东西做出来是给人用的，技术再牛逼有何用，当然两者兼顾最好。</p>
<p>原研哉在一开始的自序里就说“当你因为读完这本观念设计书而感到越来越不懂设计时，这并不意味你对设计的认识倒退了，而是证明你在设计的世界里又往更深处迈进了异步”，好吧，读完此书，再整理出来，我越来越不懂设计了。</p>
<p>摘抄：</p>
<p>0.创意并不是要让人惊异于它崭新的形式和素材，而应该让人惊异于它居然来自于看似平凡的生活。不断的开发出这些创意，才是真正的设计。</p>
<p>1.设计师从生活中发现新问题的行为</p>
<p>2.给一件事物下定义或用文字记述下来并不见得就是对其有所了解。如果能够现将已知的事物陌生化，然后再尝试挑战其真实性，才有可能深入了解它。</p>
<p>3.艺术与设计的区别？</p>
<p>艺术是艺术家在面对社会时的意志表述，其发生的根本立足点是作为个体的个人。因此，只有艺术家本人，才能够掌握其艺术发生的根源。这就是艺术的孤傲与直率之处。当然，对于一件艺术品，可以有相当多的诠释。饶有兴味的解释、鉴赏或是评论，甚至是将其汇集在一起，作为智慧性的资源加以利用，都是与艺术家以外的第三者进行艺术交流的方法。</p>
<p>而设计基本上没有自我表现的动机，其落脚点更侧重于社会，解决社会上多数人共同面临的问题，是设计的本质。在问题解决过程 —— 也是设计过程中产生的那种人类共同感受到的价值观或精神，以及由此引发的感动，这就是设计最有魅力的地方。</p>
<p>4.今天的市场是一个细分化的市场。针对每一种消费者，企业都应该做出详尽的调查。他们喜好什么？他们的潜在欲望又是什么？这都是企业应该用心研究的问题。这有这样，才能准确地预测出市场动向。精准的市场调研，到位的市场营销，即使接受顾客反馈，由此产生出来的产品必然是消费欲望的再现。</p>
<p>5.今天的 “设计”为什么容易停留在表面上呢？这是因为设计的功能与地位没有得到强调，也没有被放置在一个适合的场所当中，自然也就无法顺利运转。如果始终对设计在社会中的作用和地位不闻不问，听之任之，它就会在一定的场所中停止不动，失去活力。</p>
<p>6.设计不是一种技能，而是捕获事物本质的感觉能力和洞察能力。所以，设计师要时刻保持对社会的敏感度。顺应时代的变化，对设计领域重新配置，就成为一个重要的问题。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/du-she-ji-zhong-de-she-ji/0.jpg&quot; alt=&quot;&quot;&gt;  &lt;/p&gt;
&lt;p&gt;好吧，终于开始写读书笔记了。种种借口，一言难尽。单提到原研哉，可能不知道是谁，甚至感觉这名字奇怪，但是提到无印良品，无人不晓吧。无印良品艺术总监就是原研哉。&lt;/p&gt;
    
    </summary>
    
      <category term="破万卷" scheme="http://iYiming.me/categories/%E7%A0%B4%E4%B8%87%E5%8D%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>React Native 版本天气查询应用</title>
    <link href="http://iYiming.me/2016/07/03/2016-07-03-react-native-ban-ben-tian-qi-cha-xun-ying-yong/"/>
    <id>http://iYiming.me/2016/07/03/2016-07-03-react-native-ban-ben-tian-qi-cha-xun-ying-yong/</id>
    <published>2016-07-03T13:33:31.000Z</published>
    <updated>2016-07-03T13:42:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>效果如下：</p>
<p><img src="/images/react-native-qweather/QWeather.gif" alt="QWeather"></p>
<p>代码已传至 GitHub:</p>
<p><a href="https://github.com/iYiming/QWeather" target="_blank" rel="external">https://github.com/iYiming/QWeather</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/react-native-qweather/QWeather.gif&quot; alt=&quot;QWeather&quot;&gt;&lt;/p&gt;
&lt;p&gt;代码已传至 GitHub:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.co
    
    </summary>
    
      <category term="ReactNative" scheme="http://iYiming.me/categories/ReactNative/"/>
    
    
  </entry>
  
  <entry>
    <title>React Native 版本 ToDo List</title>
    <link href="http://iYiming.me/2016/06/20/2016-06-20-react-native-ban-ben-todo-list/"/>
    <id>http://iYiming.me/2016/06/20/2016-06-20-react-native-ban-ben-todo-list/</id>
    <published>2016-06-19T17:19:54.000Z</published>
    <updated>2016-08-12T16:09:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>写了个 React Native 版本的 ToDo List，效果如下：</p>
<h2 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h2><p><img src="/images/react-native-to-do-list/添加.gif" alt="添加"></p>
<h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><p><img src="/images/react-native-to-do-list/修改.gif" alt="修改"></p>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p><img src="/images/react-native-to-do-list/删除.gif" alt="删除"></p>
<p>代码已传至 GitHub:</p>
<p><a href="https://github.com/iYiming/ToDoList" target="_blank" rel="external">https://github.com/iYiming/ToDoList</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写了个 React Native 版本的 ToDo List，效果如下：&lt;/p&gt;
&lt;h2 id=&quot;添加&quot;&gt;&lt;a href=&quot;#添加&quot; class=&quot;headerlink&quot; title=&quot;添加&quot;&gt;&lt;/a&gt;添加&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/react-na
    
    </summary>
    
      <category term="ReactNative" scheme="http://iYiming.me/categories/ReactNative/"/>
    
    
  </entry>
  
  <entry>
    <title>Effective Objective-C 2.0 读书笔记</title>
    <link href="http://iYiming.me/2016/06/05/2016-06-05-effective-objective_c-2.0-du-shu-bi-ji/"/>
    <id>http://iYiming.me/2016/06/05/2016-06-05-effective-objective_c-2.0-du-shu-bi-ji/</id>
    <published>2016-06-05T03:40:11.000Z</published>
    <updated>2016-08-12T16:10:37.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/effective_objectivec_2.0/1.jpg" alt="1.jpg"></p>
<h2 id="第-1-章-熟悉-Objective-C"><a href="#第-1-章-熟悉-Objective-C" class="headerlink" title="第 1 章 熟悉 Objective-C"></a><a href="/blog/2016/06/05/di-1-zhang-shou-xi-objective-c/">第 1 章 熟悉 Objective-C</a></h2><h2 id="第-2-章-对象、消息、运行时"><a href="#第-2-章-对象、消息、运行时" class="headerlink" title="第 2 章 对象、消息、运行时"></a><a href="/blog/2016/06/05/di-2-zhang-dui-xiang-,-xiao-xi-,-yun-xing-shi/">第 2 章 对象、消息、运行时</a></h2><h2 id="第-3-章-接口和-API-设计"><a href="#第-3-章-接口和-API-设计" class="headerlink" title="第 3 章 接口和 API 设计"></a><a href="/blog/2016/06/05/di-3-zhang-jie-kou-he-api-she-ji/">第 3 章 接口和 API 设计</a></h2><h2 id="第-4-章-协议与分类"><a href="#第-4-章-协议与分类" class="headerlink" title="第 4 章 协议与分类"></a><a href="/blog/2016/06/05/di-4-zhang-xie-yi-yu-fen-lei/">第 4 章 协议与分类</a></h2><h2 id="第-5-章-内存管理"><a href="#第-5-章-内存管理" class="headerlink" title="第 5 章 内存管理"></a><a href="/blog/2016/06/05/di-5-zhang-nei-cun-guan-li/">第 5 章 内存管理</a></h2><h2 id="第-6-章-块与大中枢派发"><a href="#第-6-章-块与大中枢派发" class="headerlink" title="第 6 章 块与大中枢派发"></a><a href="/blog/2016/06/05/di-6-zhang-kuai-yu-da-zhong-shu-pai-fa/">第 6 章 块与大中枢派发</a></h2><h2 id="第-7-章-系统框架"><a href="#第-7-章-系统框架" class="headerlink" title="第 7 章 系统框架"></a><a href="/blog/2016/06/05/di-7-zhang-xi-tong-kuang-jia/">第 7 章 系统框架</a></h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/effective_objectivec_2.0/1.jpg&quot; alt=&quot;1.jpg&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;第-1-章-熟悉-Objective-C&quot;&gt;&lt;a href=&quot;#第-1-章-熟悉-Objective-C&quot; class=&quot;h
    
    </summary>
    
      <category term="iOS" scheme="http://iYiming.me/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>第 7 章 系统框架</title>
    <link href="http://iYiming.me/2016/06/05/2016-06-05-di-7-zhang-xi-tong-kuang-jia/"/>
    <id>http://iYiming.me/2016/06/05/2016-06-05-di-7-zhang-xi-tong-kuang-jia/</id>
    <published>2016-06-05T03:34:05.000Z</published>
    <updated>2016-06-05T03:36:31.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/effective_objectivec_2.0/1.jpg" alt="1.jpg"></p>
<p>0.CoreFoundation 与 Foundation 不仅名字相似，而且还有更为紧密的联系。Foundation 框架中的许多功能，都可以在此框架中找到对应的 C 语言 API。有个功能佳作“无缝桥接”（tollfree bridging），可以把 CoreFoundation 中的 C 语言数据结构平滑转换为 Foundation 中的 Objective-C 对象，也可以反向旋转。</p>
<p>1.ARC 下只考虑 Objective-C 对象的内存，对于非 Objective-C 对象，比如 CoreFoundation 中的需要自己考虑内存管理问题。</p>
<p>2.Objective-C 编程的一项重要特点，那就是：经常需要使用底层的 C 语言级 API。用  C 语言来实现 API 的好处是，可以绕过 Objective-C 的运行期系统，从而提升执行速度。</p>
<p>3.多用块枚举，少用 for 循环。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[array enumerateObjectsUsingBlock:^(NSString *  _Nonnull name, NSUInteger idx, BOOL * _Nonnull stop) &#123;</div><div class="line"></div><div class="line">	...</div><div class="line">	</div><div class="line">	if ([name isEqualToString:@&quot;Tom&quot;]) &#123;</div><div class="line">		stop = YES;</div><div class="line">	&#125;</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>4.块枚举优点：</p>
<ul>
<li>遍历时可以直接从块里获取更多信息。在遍历数组时，可以知道当前所针对的下标。</li>
<li>能够修改块的方法签名，以免进行类型转换操作。从效果上讲，相当于把本来需要执行的类型转换操作交给方法签名来做。</li>
</ul>
<p>5.Core Foundation 与 Foundation 内存问题</p>
<p><code>__bridge</code> 什么也不做，仅仅是转换。此种情况下：  </p>
<ol>
<li>从 Cocoa 转换到 Core，需要人工 <code>CFRetain</code>，否则，Cocoa 指针释放后， 传出去的指针则无效。</li>
<li>从 Core 转换到 Cocoa，需要人工 <code>CFRelease</code>，否则，Cocoa 指针释放后，对象引用计数仍为1，不会被销毁。</li>
</ol>
<p><code>__bridge_retained</code> 转换后自动调用 <code>CFRetain</code>，即帮助自动解决上述 1 的情形。</p>
<p><code>__bridge_transfer</code> 转换后自动调用 <code>CFRelease</code>，即帮助自动解决上述 2 的情形。  </p>
<ul>
<li><code>__bridge</code> 用法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NSString *string = [NSString stringWithFormat:...];</div><div class="line">CFStringRef cfString = (__bridge CFStringRef)string;</div></pre></td></tr></table></figure>
<p>只是单纯地执行了类型转换，没有进行所有权的转移，也就是说，当 <code>string</code> 对象被释放的时候，<code>cfstring</code> 也不能被使用了。</p>
<ul>
<li><code>__bridge_retained</code> 用法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NSString *string = [NSString stringWithFormat:...];</div><div class="line">CFStringRef cfString = (__bridge_retained CFStringRef)string;</div><div class="line">...</div><div class="line">CFRelease(cfString); // 由于Core Foundation的对象不属于ARC的管理范畴，所以需要自己release</div></pre></td></tr></table></figure>
<p>使用 <code>__bridge_retained</code> 可以通过转换目标处（ <code>cfString</code> ）的 <code>retain</code> 处理，来使所有权转移。即使 <code>string</code> 变量被释放，<code>cfString</code> 还是可以使用具体的对象。只是有一点，由于 Core Foundation 的对象不属于 ARC 的管理范畴，所以需要自己 <code>release</code>。</p>
<p>可以用 <code>CFBridgingRetain</code> 替代 <code>__bridge_retained</code> 关键字：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NSString *string = [NSString stringWithFormat:...];</div><div class="line">CFStringRef cfString = CFBridgingRetain(string);</div><div class="line">...</div><div class="line">CFRelease(cfString); // 由于Core Foundation不在ARC管理范围内，所以需要主动release。</div></pre></td></tr></table></figure>
<ul>
<li><code>__bridge_transfer</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">CFStringRef cfString = CFStringCreate...();</div><div class="line">NSString *string = (__bridge_transfer NSString *)cfString;</div><div class="line"> </div><div class="line">// CFRelease(cfString); 因为已经用 __bridge_transfer 转移了对象的所有权，所以不需要调用 release</div></pre></td></tr></table></figure>
<p>所有权被转移的同时，被转换变量将失去对象的所有权。当 Core Foundation 对象类型向Objective-C 对象类型转换的时候，会经常用到 <code>__bridge_transfer</code> 关键字。</p>
<p>同样，我们可以使用 <code>CFBridgingRelease()</code> 来代替 <code>__bridge_transfer</code> 关键字。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">CFStringRef cfString = CFStringCreate...();</div><div class="line">NSString *string = CFBridgingRelease(cfString);</div></pre></td></tr></table></figure>
<p>6.<code>NSCache</code> VS <code>NSDictionary</code></p>
<ul>
<li><code>NSCache</code> 胜过 <code>NSDictionary</code> 之处在于，当系统资源将要耗尽时，它可以自动删减缓存。如果采用普通的字典，那么就要自己编写挂钩，在系统发出“低内存”通知时手工删减缓存。</li>
<li><code>NSCache</code>还会先行删减 “最久未使用”对象。</li>
<li><code>NSCache</code>并不会拷贝键，而是会保留它。</li>
<li><code>NSCache 是线程安全的，而</code>NSDictionary`` 则绝对不具备此优势。</li>
</ul>
<p>7.只有那种“重新计算起来很费事的”数据，才值得放入缓存，比如那些需要从网络获取或从磁盘获取的数据。</p>
<p>8.<code>+ (void)load</code> 方法</p>
<ul>
<li><code>+ (void)load</code>，对于加入运行期系统的每个类以及分类来说，必定会调用此方法，而且仅调用一次。当包含类或分类的程序库载入系统时，就会执行此方法，而这通常就是指应用程序启动的时候，若程序是为 iOS 平台设计的，则肯定会在此时执行。</li>
<li>在 <code>load</code> 方法中使用其他类是不安全的。</li>
<li><code>load</code> 方法并不像普通的方法那样，它并不遵从那套继承规则。分类和所属的类里，都可能出现 load 方法。此时两种实现代码都会调用，类的实现要比分类的实现先执行。</li>
<li><code>load</code> 方法务必实现得精简些，也就是要尽量减少其所执行的操作，因为整个应用程序在执行 <code>load</code> 方法时都会阻塞。</li>
</ul>
<p>9.<code>+ (void)initialize</code> 方法</p>
<ul>
<li>对于每个类来说，该方法会在程序首次用该类之前调用，且只调用一次。它是惰性调用的，只有程序用到了相关的类时，才会调用。</li>
<li>此方法与 <code>+ (void)load</code>方法不同的是，运行期系统在执行该方法时，是处于正常状态的，因此，从运行期系统完整度上来讲，此时可以完全使用并调用任意类中的任意方法。</li>
<li><code>+ (void) initialize</code> 方法与其他消息一样，如果某个类未实现它，而其超类实现了，那么就会运行超类实现的代码。</li>
</ul>
<p>10.<code>NSTimer</code> 会保留其目标对象。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">#import &quot;YMTimerCircularReferenceViewController.h&quot;</div><div class="line"></div><div class="line">@interface YMTimerCircularReferenceViewController ()</div><div class="line"></div><div class="line">@property (nonatomic, strong) NSTimer *timer;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation YMTimerCircularReferenceViewController</div><div class="line"></div><div class="line">- (void)viewDidLoad &#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    </div><div class="line">    self.timer = [NSTimer timerWithTimeInterval:1 target:self selector:@selector(timerSelector) userInfo:nil repeats:YES];</div><div class="line">    [[NSRunLoop currentRunLoop] addTimer:self.timer forMode:NSDefaultRunLoopMode];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)timerSelector &#123;</div><div class="line">    NSLog(@&quot;%@&quot;,[NSDate date]);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)dealloc &#123;</div><div class="line">    NSLog(@&quot;YMTimerCircularReferenceViewController dealloc&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当 <code>YMTimerCircularReferenceViewController</code> pop 时，上面的 <code>dealloc</code>方法不被调用。</p>
<p>解决办法，加一个 NSTimer 类别：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">#import &quot;NSTimer+YMBlock.h&quot;</div><div class="line"></div><div class="line">@implementation NSTimer (YMBlock)</div><div class="line"></div><div class="line">+ (NSTimer * _Nonnull)ym_timerWithTimeInterval:(NSTimeInterval)ti block:(nullable void (^)())block userInfo:(nullable id)userInfo repeats:(BOOL)yesOrNo &#123;</div><div class="line">    return [self timerWithTimeInterval:ti target:self selector:@selector(ym_blockInvoke:) userInfo:[block copy] repeats:yesOrNo];</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (void)ym_blockInvoke:(NSTimer *)timer &#123;</div><div class="line">    void (^block)() = timer.userInfo;</div><div class="line">    </div><div class="line">    if (block) &#123;</div><div class="line">        block();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>注：此处虽然依然有保留换，<code>self</code> 引用 <code>self</code>，因为是类对象，无须回收。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/effective_objectivec_2.0/1.jpg&quot; alt=&quot;1.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;0.CoreFoundation 与 Foundation 不仅名字相似，而且还有更为紧密的联系。Foundation 框架中的许多功
    
    </summary>
    
      <category term="iOS" scheme="http://iYiming.me/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>第 6 章 块与大中枢派发</title>
    <link href="http://iYiming.me/2016/06/05/2016-06-05-di-6-zhang-kuai-yu-da-zhong-shu-pai-fa/"/>
    <id>http://iYiming.me/2016/06/05/2016-06-05-di-6-zhang-kuai-yu-da-zhong-shu-pai-fa/</id>
    <published>2016-06-05T03:32:44.000Z</published>
    <updated>2016-08-14T00:46:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/effective_objectivec_2.0/1.jpg" alt="1.jpg"></p>
<p>0.如果块所捕获的变量是对象类型，那么就会自动保留它。系统在释放这个块的时候，也会将其一并释放。</p>
<p>1.如果将块定义在 Objective-C 类的实例方法中，那么除了可以访问类的所有实例变量之外，还可以使用 <code>self</code> 变量。块总能修改实例变量。所以在声明时无须加 <code>__block</code>。不过，如果通过读取或写入操作捕获了实例变量，那么也会自动把 <code>self</code> 变量一并捕获了，因为实例变量是与 <code>self</code> 所只带的实例关联在一起的。</p>
<p>2.在 block 中 直接访问实例变量和通过 <code>self</code> 来访问是等效的。</p>
<p>3.一定要记住：<code>self</code> 也是个对象，因而快在捕获它时也会将其保留。如果 <code>self</code> 所指点的那个对象同时也保留了块，那么这种情况通常就会导致“保留环”。</p>
<p>4.除了 “栈块” 和 “堆块”之外，还有一类块叫做 “全局块”（global block）。这种块不会捕捉任何状态（比如外围的变量等），运行时也无须有状态来参与。块所使用的整个内存区域，在编译期已经完全确定了，因此，全局块可以生命在全局内存里，而不需要在每次用到的时候于栈中创建。另外，全局块的拷贝操作是个空操作，因为全局块决不可能为系统所回收。这种块实际上相当于单例。</p>
<p>下面两种方式都是全局块（global block）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">void (^myFirstBlock)() = ^&#123;</div><div class="line">    NSLog(@&quot;123&quot;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">void (^mySecondBlock)(int a,int b) = ^(int a,int b)&#123;</div><div class="line">    NSLog(@&quot;a + b = %@&quot;,@(a + b));</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>5.以 <code>typedef</code> 重新定义块类型，可令块变量用起来更加简单。</p>
<p>6.不妨为同一个块签名定义多个类型别名。如果要重构的代码使用了块类型的某个别名，那么只需修改相应 <code>typedef</code> 中的块签名即可，无须改动其他 <code>typedef</code>。</p>
<p>7.与使用委托模式的代码相比，用块写出来的代码更为整洁。委托模式有个缺点：如果类要分别使用多个获取器下载不同数据，那么就得在 <code>delegate</code> 回调方法里根据传入的获取器参数来切换。</p>
<p>8.建议使用同一个块来处理成功与失败情况，苹果公司似乎也是这样设计 API 的。</p>
<p>9.如果块所捕获的对象直接或间接地保留了块本身，那么就得当心保留环问题。一定要找个适当的时机解除保留环，而不能把责任推给 API 的调用者。</p>
<p>10.在 Objective-C 中，如果有多个线程要执行同一份代码，那么有时可能会出现问题。这种情况下，通常要使用锁来实现某种同步机制。在 GCD 出现之前，有两种办法:</p>
<ul>
<li>内置的 <code>@synchronize</code></li>
<li>使用 <code>NSLock</code> 对象</li>
</ul>
<p>11.滥用 <code>@synchronized(self)</code> 则会降低代码效率，因为共用同一个锁的那些同步块，都必须按顺序执行。若是在 <code>self</code> 对象上频繁枷锁，那么程序可能要等另一段于此无关的代码执行完毕，才能继续执行当前代码，这样做其实并没有必要。在极端情况下，<code>@synchronize</code> 块会导致死锁，另外，其效率也不见得很高。</p>
<p>12.派发队列可用来表述同步寓意，这样做法要比使用 <code>@synchronized</code> 块或 <code>NSLock</code> 对象更简单。</p>
<p>13.有种简单高效的办法可以代替同步块或锁对象，那就是使用“串行同步队列”。 </p>
<p>14.如果将串行同步队列改为串行异步队列，貌似看起来效率更高些，但这么改动有个坏处：如果你测一下程序性能，那么可能会发现这种写法比原来慢，因为执行异步派发时，需要拷贝块。若拷贝块所用的时间明显超过执行块所花的实现，则这种做法将比原来更慢。</p>
<p>15.多个获取方法可以并发执行，而获取方法与设置方法之间不能并发执行，利用这个特点，还能写出更快一些的代码块。利用<code>dispatch_brarrier_async</code>，我们可以使用并行队列。并发队列如果发现接下来要处理的块是个栅栏块。待栅栏块执行过后，再按正常方式继续向下处理。</p>
<p>16.多用 GCD，少用 <code>performSelector</code>。</p>
<p>17.使用 <code>performSelector</code>,编译器并不知道将要调用的选择子是什么，因此，也就不了解其方法签名及返回值，甚至连是否有返回值都不清楚。而且，由于编译器不知道方法名，所以就没办法运用 ARC 的内存管理规则来判定返回值是不是应该释放。鉴于此，ARC 采用了比较谨慎的做法，就是不添加释放操作。然而这么做可能导致内存泄漏，因为方法在返回对象时可能已经将其保留了。</p>
<p>18.延后执行可以用 <code>dispatch_after</code> 来实现。</p>
<p>19.GCD VS NSOperation</p>
<p>GCD 的优点：</p>
<ul>
<li>GCD 提供的 <code>dispatch_after</code> 支持调度下一个操作的开始时间而不是直接进入睡眠。</li>
<li><code>NSOperation</code> 中没有类似<code>dispatch_source_t</code>, <code>dispatch_io,dispatch_data_t</code>, <code>dispatch_semaphore_t</code> 等操作。  </li>
</ul>
<p><code>NSOperation</code> 的优点：</p>
<ul>
<li>GCD 没有操作依赖。我们可以让一个 Operation 依赖于另一个 Operation，这样的话尽管两个 Operation 处于同一个并行队列中，但前者会直到后者执行完毕后再执行；<br>GCD 没有操作优先级（GCD 有队列优先级），能够使同一个并行队列中的任务区分先后地执行，而在 GCD 中，我们只能区分不同任务队列的优先级，如果要区分block任务的优先级，也需要大量的复杂代码；</li>
<li>GCD 没有 KVO。<code>NSOperation</code> 可以监听一个 Operation 是否完成或取消，这样能比 GCD 更加有效地掌控我们执行的后台任务</li>
<li>在 <code>NSOperationQueue</code> 中，我们可以随时取消已经设定要准备执行的任务(当然，已经开始的任务就无法阻止了)，而 GCD 没法停止已经加入 queue 的 block (其实是有的，但需要许多复杂的代码)</li>
<li>我们能够对 <code>NSOperation</code> 进行继承，在这之上添加成员变量与成员方法，提高整个代码的复用度，这比简单地将 block 任务排入执行队列更有自由度，能够在其之上添加更多自定制的功能。</li>
</ul>
<p>20.使用 Dispatch Group,并行执行 A、B 任务，最后执行 C 任务：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t concurrentQueue = dispatch_queue_create(&quot;me.iYiming.concurrentQueue&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class="line"></div><div class="line">dispatch_group_t group = dispatch_group_create();</div><div class="line"></div><div class="line">dispatch_group_async(group, concurrentQueue, ^&#123;</div><div class="line">   // A 任务</div><div class="line">&#125;);</div><div class="line"></div><div class="line">dispatch_group_async(group, concurrentQueue, ^&#123;</div><div class="line">   // B 任务</div><div class="line">&#125;);</div><div class="line"></div><div class="line">dispatch_group_notify(group, concurrentQueue, ^&#123;</div><div class="line">   // C 任务</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>21.使用 <code>dispatch_once</code> 创建单例：</p>
<p>单例：<strong>保证只分配一次内存</strong>  </p>
<ul>
<li>调用 <code>alloc</code> 方法的时候，内部会调用 <code>allocWithZone</code> 方法，所以控制好 <code>allocWithZone</code> 方法的内存开辟操作就能控制 <code>alloc</code> </li>
<li><p><code>copy</code>、<code>mutableCopy</code> 同样要控制，直接返回调用者就好（因为 <code>copy</code> 和 <code>mutableCopy</code> 是对象方法，所以如果第一次内存分配控制好了，这里直接返回 <code>self</code>）  </p>
</li>
<li><p>MRC 下 <code>retain</code>、<code>release</code>、<code>retainCount</code> 处理</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">//保存单例对象的静态全局变量</div><div class="line">static id _instance;</div><div class="line">+ (instancetype)sharedTools &#123;</div><div class="line">    return [[self alloc]init];</div><div class="line">&#125;</div><div class="line">//在调用alloc方法之后，最终会调用allocWithZone方法</div><div class="line">+ (instancetype)allocWithZone:(struct _NSZone *)zone &#123;</div><div class="line">    //保证分配内存的代码只执行一次</div><div class="line">    static dispatch_once_t onceToken;</div><div class="line">    dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">        _instance = [super allocWithZone:zone];</div><div class="line">    &#125;);</div><div class="line">    return _instance;</div><div class="line">&#125;</div><div class="line">//这是个对象方法，既然有对象而且是单例，那么调用者就是这个单例对象了，那就返回调用的对象就行</div><div class="line">- (id)copyWithZone:(NSZone *)zone &#123;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line">//这是个对象方法，既然有对象而且是单例，那么调用者就是这个单例对象了，那就返回调用的对象就行</div><div class="line">- (id)mutableCopyWithZone:(NSZone *)zone &#123;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line">#if __has_feature(objc_arc)</div><div class="line">//如果是ARC环境</div><div class="line">#else</div><div class="line">//如果不是ARC环境</div><div class="line"></div><div class="line">//既然是单例对象，总不能被人给销毁了吧，一旦销毁了，分配内存的代码已经执行过了，就再也不能创建对象了。所以覆盖掉release操作</div><div class="line">- (oneway void)release &#123;</div><div class="line">&#125;</div><div class="line">//这是个对象方法，既然有对象而且是单例，那么调用者就是这个单例对象了，那就返回调用的对象就行</div><div class="line">- (instancetype)retain &#123;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line">//为了便于识别，这里返回 MAXFLOAT ，别的程序员看到这个数据，就能意识到这是单例。</div><div class="line">- (NSUInteger)retainCount &#123;</div><div class="line">    return MAXFLOAT;</div><div class="line">&#125;</div><div class="line">#endif</div></pre></td></tr></table></figure>
<p>22.<code>dispatch_sync</code> 执行 block 所在的 Queue 如果和当前 Queue 是同一个 Queue，那么会造成死锁。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (void)viewDidLoad &#123;</div><div class="line">  [super viewDidLoad];</div><div class="line">  </div><div class="line">  dispatch_sync(dispatch_get_main_queue(),^&#123;</div><div class="line">    NSLog(@&quot;Hello !&quot;);</div><div class="line">  &#125;);</div><div class="line">  </div><div class="line">  NSLog(@&quot;结束&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>为什么？因为 <code>dispatch_sync</code> 是同步的，又在 <code>viewDidLoad</code> 里，所以主线程等待它执行完才能打印“结束“，然而 <code>dispatch_sync</code> 块需要在 <code>dispatch_get_main_queue()</code> 主线程里添加 block <code>^{
    NSLog(@&quot;Hello !&quot;);
  })</code>,因为主线程现在在等待中，所以 Block 永远无法添加进主线程队列中去，互相等待，从而造成死锁。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/effective_objectivec_2.0/1.jpg&quot; alt=&quot;1.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;0.如果块所捕获的变量是对象类型，那么就会自动保留它。系统在释放这个块的时候，也会将其一并释放。&lt;/p&gt;
&lt;p&gt;1.如果将块定义在 O
    
    </summary>
    
      <category term="iOS" scheme="http://iYiming.me/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>第 5 章 内存管理</title>
    <link href="http://iYiming.me/2016/06/05/2016-06-05-di-5-zhang-nei-cun-guan-li/"/>
    <id>http://iYiming.me/2016/06/05/2016-06-05-di-5-zhang-nei-cun-guan-li/</id>
    <published>2016-06-05T03:29:20.000Z</published>
    <updated>2016-08-14T00:48:38.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/effective_objectivec_2.0/1.jpg" alt="1.jpg"></p>
<p>下图列出了一些 ARC 下的内存问题，就各个问题一一描述下： </p>
<p><img src="/images/effective_objectivec_2.0/2.png" alt="2.jpg"></p>
<h2 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h2><h4 id="普通的两个变量互相引用"><a href="#普通的两个变量互相引用" class="headerlink" title="普通的两个变量互相引用"></a>普通的两个变量互相引用</h4><p>上代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">self.object1 = [[YMNormalCircularReferenceObject alloc] init];</div><div class="line">self.object2 = [[YMNormalCircularReferenceObject alloc] init];</div><div class="line"></div><div class="line">self.object1.data = self.object2;</div><div class="line">self.object2.data = self.object1;</div></pre></td></tr></table></figure>
<p>两个对象互相引用，解决办法一个使用 <code>weak</code> 标识属性。</p>
<h4 id="Block-循环引用"><a href="#Block-循环引用" class="headerlink" title="Block 循环引用"></a>Block 循环引用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">#import &quot;YMBlockCircularReferenceViewController.h&quot;</div><div class="line"></div><div class="line">typedef void(^YMDownloaderCompleteBlock)(id data);</div><div class="line"></div><div class="line">@interface YMDownloader ()</div><div class="line"></div><div class="line">@property (nonatomic, copy) YMDownloaderCompleteBlock downloaderCompleteBlock;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation YMDownloader</div><div class="line"></div><div class="line"></div><div class="line">- (void)downloadDataWithURL:(NSURL *)url completeBlock:(YMDownloaderCompleteBlock)block &#123;</div><div class="line">    self.downloaderCompleteBlock = block;</div><div class="line">    </div><div class="line">    [self downloadDataWithURL:url];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)downloadDataWithURL:(NSURL *)url &#123;</div><div class="line">    dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</div><div class="line">        sleep(2);</div><div class="line">        </div><div class="line">        self.downloaderCompleteBlock(url);</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line"></div><div class="line">@interface YMBlockCircularReferenceViewController ()</div><div class="line"></div><div class="line">@property (nonatomic, strong) YMDownloader *downloader;</div><div class="line">@property (nonatomic, strong) id data;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation YMBlockCircularReferenceViewController</div><div class="line"></div><div class="line">- (void)viewDidLoad &#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    </div><div class="line">    self.downloader = [[YMDownloader alloc] init];</div><div class="line">    [self.downloader downloadDataWithURL:[NSURL URLWithString:@&quot;&quot;] completeBlock:^(id data) &#123;</div><div class="line">        self.data = data;</div><div class="line">    &#125;];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)dealloc &#123;</div><div class="line">    NSLog(@&quot;YMBlockCircularReferenceViewController dealloc 方法&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p><code>self</code> 保留了 <code>downloader</code> ，<code>downloader</code> 拷贝了块，块里保留了 <code>self</code>,解决办法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (void)downloadDataWithURL:(NSURL *)url &#123;</div><div class="line">    dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</div><div class="line">        sleep(2);</div><div class="line">        </div><div class="line">        self.downloaderCompleteBlock(url);</div><div class="line">        self.downloaderCompleteBlock = nil;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="NSTimer"><a href="#NSTimer" class="headerlink" title="NSTimer"></a>NSTimer</h4><p><code>NSTimer</code> 会保留其目标对象</p>
<p>继续上代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">#import &quot;YMTimerCircularReferenceViewController.h&quot;</div><div class="line"></div><div class="line">@interface YMTimerCircularReferenceViewController ()</div><div class="line"></div><div class="line">@property (nonatomic, strong) NSTimer *timer;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation YMTimerCircularReferenceViewController</div><div class="line"></div><div class="line">- (void)viewDidLoad &#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    </div><div class="line">    self.timer = [NSTimer timerWithTimeInterval:1 target:self selector:@selector(timerSelector) userInfo:nil repeats:YES];</div><div class="line">    [[NSRunLoop currentRunLoop] addTimer:self.timer forMode:NSDefaultRunLoopMode];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)timerSelector &#123;</div><div class="line">    NSLog(@&quot;%@&quot;,[NSDate date]);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)dealloc &#123;</div><div class="line">    NSLog(@&quot;YMTimerCircularReferenceViewController dealloc&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当 <code>YMTimerCircularReferenceViewController</code> pop 时，上面的 <code>dealloc</code>方法不被调用。</p>
<p>解决办法，加一个 <code>NSTimer</code> 类别：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">#import &quot;NSTimer+YMBlock.h&quot;</div><div class="line"></div><div class="line">@implementation NSTimer (YMBlock)</div><div class="line"></div><div class="line">+ (NSTimer * _Nonnull)ym_timerWithTimeInterval:(NSTimeInterval)ti block:(nullable void (^)())block userInfo:(nullable id)userInfo repeats:(BOOL)yesOrNo &#123;</div><div class="line">    return [self timerWithTimeInterval:ti target:self selector:@selector(ym_blockInvoke:) userInfo:[block copy] repeats:yesOrNo];</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (void)ym_blockInvoke:(NSTimer *)timer &#123;</div><div class="line">    void (^block)() = timer.userInfo;</div><div class="line">    </div><div class="line">    if (block) &#123;</div><div class="line">        block();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>注：此处虽然依然有保留换，<code>self</code> 引用 <code>self</code>，因为是类对象，无须回收。<code>CADisplayLink</code> 类似。</p>
<h4 id="悬挂指针"><a href="#悬挂指针" class="headerlink" title="悬挂指针"></a>悬挂指针</h4><p>在 Scheme 中开启即可，如下图：</p>
<p><img src="/images/effective_objectivec_2.0/3.png" alt="3.jpg"></p>
<h2 id="持有、释放不匹配"><a href="#持有、释放不匹配" class="headerlink" title="持有、释放不匹配"></a>持有、释放不匹配</h2><h4 id="performselector"><a href="#performselector" class="headerlink" title="performselector"></a>performselector</h4><p>使用 <code>performSelector</code>,编译器并不知道将要调用的选择子是什么，因此，也就不了解其方法签名及返回值，甚至连是否有返回值都不清楚。而且，由于编译器不知道方法名，所以就没办法运用 ARC 的内存管理规则来判定返回值是不是应该释放。鉴于此，ARC 采用了比较谨慎的做法，就是不添加释放操作。然而这么做可能导致内存泄漏，因为方法在返回对象时可能已经将其保留了。</p>
<h4 id="CoreFoundation-Foundation"><a href="#CoreFoundation-Foundation" class="headerlink" title="CoreFoundation - Foundation"></a>CoreFoundation - Foundation</h4><p>上代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">- (IBAction)coreFoundationToFoundation:(id)sender &#123;</div><div class="line">   CFStringRef coreFoundationStr = CFStringCreateWithCString(NULL, &quot;Hello World!&quot;, kCFStringEncodingUnicode);</div><div class="line">    </div><div class="line">    NSString *foundationStr = (__bridge NSString *)(coreFoundationStr);</div><div class="line">    // NSString *foundationStr = CFBridgingRelease(coreFoundationStr);</div><div class="line">    </div><div class="line">    NSLog(@&quot;foundationStr:%@&quot;,foundationStr);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (IBAction)foundationToCoreFoundation:(id)sender &#123;</div><div class="line">    NSString *foundationStr = [[NSString alloc] initWithFormat:@&quot;Hello World!&quot;];</div><div class="line">    </div><div class="line">    CFStringRef coreFoundationStr = CFBridgingRetain(foundationStr);</div><div class="line">    NSLog(@&quot;coreFoundationStr:%@&quot;,coreFoundationStr);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (IBAction)noMemoryManagement:(id)sender &#123;</div><div class="line">    // NSString *foundationStr = @&quot;Hello World!&quot;;</div><div class="line">    // CFStringRef coreFoundationStr = (__bridge CFStringRef)(foundationStr);</div><div class="line">    </div><div class="line">    </div><div class="line">    // CFStringRef coreFoundationStr = CFStringCreateWithCString(NULL, &quot;Hello World!&quot;, kCFStringEncodingUnicode);</div><div class="line">    // NSString *foundationStr = (__bridge NSString *)(coreFoundationStr);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Core Foundation 与 Foundation 内存问题</p>
<p><code>__bridge</code> 什么也不做，仅仅是转换。此种情况下：  </p>
<ol>
<li>从 Cocoa 转换到 Core，需要人工 <code>CFRetain</code>，否则，Cocoa 指针释放后， 传出去的指针则无效。</li>
<li>从 Core 转换到 Cocoa，需要人工 <code>CFRelease</code>，否则，Cocoa 指针释放后，对象引用计数仍为1，不会被销毁。</li>
</ol>
<p><code>__bridge_retained</code> 转换后自动调用 <code>CFRetain</code>，即帮助自动解决上述 1 的情形。</p>
<p><code>__bridge_transfer</code> 转换后自动调用 <code>CFRelease</code>，即帮助自动解决上述 2 的情形。  </p>
<ul>
<li><code>__bridge</code> 用法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NSString *string = [NSString stringWithFormat:...];</div><div class="line">CFStringRef cfString = (__bridge CFStringRef)string;</div></pre></td></tr></table></figure>
<p>只是单纯地执行了类型转换，没有进行所有权的转移，也就是说，当 <code>string</code> 对象被释放的时候，<code>cfstring</code> 也不能被使用了。</p>
<ul>
<li><code>__bridge_retained</code> 用法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NSString *string = [NSString stringWithFormat:...];</div><div class="line">CFStringRef cfString = (__bridge_retained CFStringRef)string;</div><div class="line">...</div><div class="line">CFRelease(cfString); // 由于Core Foundation的对象不属于ARC的管理范畴，所以需要自己release</div></pre></td></tr></table></figure>
<p>使用 <code>__bridge_retained</code> 可以通过转换目标处（ <code>cfString</code> ）的 <code>retain</code> 处理，来使所有权转移。即使 <code>string</code> 变量被释放，<code>cfString</code> 还是可以使用具体的对象。只是有一点，由于 Core Foundation 的对象不属于 ARC 的管理范畴，所以需要自己 <code>release</code>。</p>
<p>可以用 <code>CFBridgingRetain</code> 替代 <code>__bridge_retained</code> 关键字：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NSString *string = [NSString stringWithFormat:...];</div><div class="line">CFStringRef cfString = CFBridgingRetain(string);</div><div class="line">...</div><div class="line">CFRelease(cfString); // 由于Core Foundation不在ARC管理范围内，所以需要主动release。</div></pre></td></tr></table></figure>
<ul>
<li><code>__bridge_transfer</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">CFStringRef cfString = CFStringCreate...();</div><div class="line">NSString *string = (__bridge_transfer NSString *)cfString;</div><div class="line"> </div><div class="line">// CFRelease(cfString); 因为已经用 __bridge_transfer 转移了对象的所有权，所以不需要调用 release</div></pre></td></tr></table></figure>
<p>所有权被转移的同时，被转换变量将失去对象的所有权。当 Core Foundation 对象类型向 Objective-C 对象类型转换的时候，会经常用到 <code>__bridge_transfer</code> 关键字。</p>
<p>同样，我们可以使用 <code>CFBridgingRelease()</code> 来代替 <code>__bridge_transfer</code> 关键字。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">CFStringRef cfString = CFStringCreate...();</div><div class="line">NSString *string = CFBridgingRelease(cfString);</div></pre></td></tr></table></figure>
<p>— 华丽分割线 —</p>
<p>其实看完上面的解释，就不用介绍上面代码出现的问题了。简要说下：</p>
<p>0.<code>- (IBAction)coreFoundationToFoundation:(id)sender</code> 方法创建了 CFStringRef 对象，并未使用，需要使用下面代码释放：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSString *foundationStr = CFBridgingRelease(coreFoundationStr);</div></pre></td></tr></table></figure>
<p>1.<code>- (IBAction)foundationToCoreFoundation:(id)sender</code> 方法里接手并<code>retain</code> 了 Objective-C 对象的字符串，但是没有做到释放。</p>
<h4 id="try-…-catch"><a href="#try-…-catch" class="headerlink" title="@try … @catch"></a>@try … @catch</h4><p>再上代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">- (void)viewDidLoad &#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    </div><div class="line">    @try &#123;</div><div class="line">        NSArray *array = @[@&quot;a&quot;, @&quot;b&quot;, @&quot;c&quot;];</div><div class="line">        [array objectAtIndex:3];</div><div class="line">    &#125; @catch (NSException *exception) &#123;</div><div class="line">        // 处理异常</div><div class="line">        NSLog(@&quot;throw an exception: %@&quot;, exception.reason);</div><div class="line">    &#125; @finally &#123;</div><div class="line">        NSLog(@&quot;正常执行&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当执行到 <code>[array objectAtIndex:3];</code> 发生崩溃，这时 <code>array</code> 并未释放，解决办法是开启编译器标志 <code>-fobjc-arc-exceptions</code></p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h4 id="autoreleasepool-block-降低内存峰值"><a href="#autoreleasepool-block-降低内存峰值" class="headerlink" title="@autoreleasepool block 降低内存峰值"></a>@autoreleasepool block 降低内存峰值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">for (id object in array) &#123;</div><div class="line">	@@autoreleasepool &#123;</div><div class="line">		...</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>合理运用自动释放池，可降低应用程序的内存峰值。</p>
<p>是否应该用 <code>@autoreleasepool { }</code> 来优化效率，完全取决于具体的应用程序。首先得监控内存用量，判断其中有没有需要解决的问题，如果没完成这一步，那就别急着优化。尽管<code>@autoreleasepool { }</code> 的开销不太大，但毕竟还是有的，所以尽量不要建立额外的自动释放池。</p>
<h4 id="需自己负责释放方法命名规则"><a href="#需自己负责释放方法命名规则" class="headerlink" title="需自己负责释放方法命名规则"></a>需自己负责释放方法命名规则</h4><p>在一开始的图中的几个方法，需要在 MRC 下需要对象自己手动释放。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/effective_objectivec_2.0/1.jpg&quot; alt=&quot;1.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;下图列出了一些 ARC 下的内存问题，就各个问题一一描述下： &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/effective_
    
    </summary>
    
      <category term="iOS" scheme="http://iYiming.me/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>第 4 章 协议与分类</title>
    <link href="http://iYiming.me/2016/06/05/2016-06-05-di-4-zhang-xie-yi-yu-fen-lei/"/>
    <id>http://iYiming.me/2016/06/05/2016-06-05-di-4-zhang-xie-yi-yu-fen-lei/</id>
    <published>2016-06-05T03:27:45.000Z</published>
    <updated>2016-06-05T03:28:32.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images//effective_objectivec_2.0/1.jpg" alt="1.jpg"></p>
<p>0.利用分类机制，我们无须继承子类即可直接为当前类添加方法，而在其他编程语言中，则需通过集成子类来实现。由于 Objective-C 运行期系统是高度动态的，所以才支持这一特性。</p>
<p>1.使用分类机制把类的实现代码划分成易于管理的小块</p>
<p>2.将应该视为“私有”的方法归入名叫 Private 的分类中，以隐藏实现细节。</p>
<p>3.分类中的方法是直接添加在类里面的，他们就好比这个类中的固有方法。将分类方法加入类中这一操作是在运行期系统加载分类时完成的。运行期系统会把分类中所实现的每个方法都加入类的方法列表中。如果类中本来就有此方法，而分类又实现了一次，那么分类中的方法会覆盖原来那一份实现代码。实际上可能会发生很多次覆盖，比如某个分类中的方法覆盖了“主实现”中的相关方法，而另外一个分类中的方法又覆盖了这个分类中的方法。多次覆盖的结果以最后一个分类为准。</p>
<p>4.要解决上述问题，一般的做法是：以命名空间来区别各个分类的名称与其中所定义的方法。想在 Objective-C 中实现命名空间功能，只有一个办法，就是给相关名称都加上某个公用的前缀。</p>
<p>5.除了 class-continuation 分类 之外，其他分类都无法向勒种新增实例变量，因此，他们无法把实现属性所需的实例变量合成出来。</p>
<p>6.通过类的匿名分类向类中新增实例变量，如果某属性在主接口中声明为“只读”，而类的内部又要用设置方法修改此属性，那么就在匿名分类中将其扩展为可读写</p>
<p>7.若想使类所遵循的协议不为人所知，则可以在匿名分类中声明</p>
<p>8.协议可在某种程度上提供匿名类型。具体的对象类型可以淡化成遵从某协议的 id 类型，协议里规定了对象所应实现的方法。</p>
<p>9.使用匿名对象来隐藏类型名称（或类名）。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images//effective_objectivec_2.0/1.jpg&quot; alt=&quot;1.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;0.利用分类机制，我们无须继承子类即可直接为当前类添加方法，而在其他编程语言中，则需通过集成子类来实现。由于 Objective-C
    
    </summary>
    
      <category term="iOS" scheme="http://iYiming.me/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>第 3 章 接口和 API 设计</title>
    <link href="http://iYiming.me/2016/06/05/2016-06-05-di-3-zhang-jie-kou-he-api-she-ji/"/>
    <id>http://iYiming.me/2016/06/05/2016-06-05-di-3-zhang-jie-kou-he-api-she-ji/</id>
    <published>2016-06-05T03:25:23.000Z</published>
    <updated>2016-08-14T00:49:48.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images//effective_objectivec_2.0/1.jpg" alt="1.jpg"></p>
<p>0.Objective-C 没有其他语言那种内置的命名空间（namespace）机制。鉴于此，我们在起名时要设法避免潜在的命名冲突，否则很容易就重名了。如果发生命名冲突，那么应用程序的链接过程就会出错，因为其中出现了重复符号,<code>duplicate symbol</code>错误。</p>
<p>1.避免此问题的唯一办法就是变相实现命名空间：为所有名称都加上适当前缀。使用 Cocoa 创建应用程序时一定要注意，Apple 宣称其保留使用所有“两字母前缀”的权利，所以自己选用的前缀应该是三个字母的。</p>
<p>2.不仅是类名，应用程序中的所有名称都应该加上前缀。如果要既有类新增 category，那么一定要给 “分类” 及分类中方法加上前缀。</p>
<p>3.在类中提供一个全能初始化方法，并于文档里指明。其他初始化方法均应调用此方法，若全能初始化方法与超类不同，则需复写超类中的对应方法（所谓的全能初始化方法就是，其他初始化方法都要调用它，如 <code>NSDate</code> 中的 <code>initWithTimeIntervalSinceReferenceDate:</code> 就是全能初始化方法）。</p>
<p>4.NSObject 协议中还有个方法要注意，那就是 <code>debugDescription</code>，此方法的用意与 <code>description</code> 非常相似。二者区别在于，<code>debugDescription</code> 方法是开发者在调试器（debugger）中以控制台命令打印对象时才调用的。在 <code>NSObject</code> 类的默认视线中，此方法知识直接调用了 <code>description</code>。</p>
<p>5.实现 <code>description</code> 方法返回一个有意义的字符串，用以描述该实例。若想在调试时打印出更详尽的对象描述信息，则应实现 <code>debugDescription</code> 方法.</p>
<p>6.默认情况下，属性是“既可读又可写的”，这样设计出来的类都是“可变的”。一般情况下我们要建模的数据未必需要改变。具体到编程实践中，则应该尽量把对外公布出来的属性设为只读，而且只在确有必要时才将属性对外公布。再将属性在对象内部重新声明为 <code>readwrite</code>。</p>
<p>7.给私有化方法名称添加前缀（<code>p_method</code>, <code>p</code> 表示私有）。苹果公司喜欢单用一个下划线作为私有方法的前缀。你也许也想照着苹果公司的办法指哪一个下划线作前缀，这样做可能会惹来大麻烦：如果苹果公司提供的某个类中继承了一个子类，那么你在子类里可能会无意间复写了父类的同名方法，鉴于此，苹果公司在文档中说，开发者不应该单用一个下划线做前缀。</p>
<p>8.若想令自己缩写的对象具有拷贝功能，则需要实现 <code>NSCoping</code> 协议</p>
<p>9.如果自订一个对象分为可变版本与不可变版本。那么就要同事实现 <code>NSCoping</code> 与 <code>NSMutableCopying</code> 协议。</p>
<p>10.在可变对象上调用 <code>copy</code> 方法会返回另外一个不可变类的实例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[NSMutableArray copy] =&gt; NSArray</div><div class="line">[NSArray mutableCopy] =&gt; NSMutableArray</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images//effective_objectivec_2.0/1.jpg&quot; alt=&quot;1.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;0.Objective-C 没有其他语言那种内置的命名空间（namespace）机制。鉴于此，我们在起名时要设法避免潜在的命名冲突，
    
    </summary>
    
      <category term="iOS" scheme="http://iYiming.me/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>第 2 章 对象、消息、运行时</title>
    <link href="http://iYiming.me/2016/06/05/2016-06-05-di-2-zhang-dui-xiang-xiao-xi-yun-xing-shi/"/>
    <id>http://iYiming.me/2016/06/05/2016-06-05-di-2-zhang-dui-xiang-xiao-xi-yun-xing-shi/</id>
    <published>2016-06-05T03:22:07.000Z</published>
    <updated>2016-08-14T00:50:31.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images//effective_objectivec_2.0/1.jpg" alt="1.jpg"></p>
<p>0.用 Objective-C 等面向对象语言编程时，“对象”就是“基本构造单元”（building block），开发者可以通过对象来存储并传递数据。在对象之间传递数据并执行任务的过程就叫做“消息传递”（Messaging）。</p>
<p>1.当应用程序运行起来以后，为其提供相关支持的代码叫做“Objective-C 运行期环境”（Objective-C Runtime），它提供了一些使得对象之间能够提供消息的重要函数，并且包含创建类实例所用的全部逻辑。在理解了运行期环境中各个部分协同工作的原理之后，你的开发水平将会进一步提升。</p>
<p>2.属性（property）是 Objective-C 的一项特性，用于封装对象中的数据。Objective-C对象通常会把其所需要的数据保存为各种实例变量。实例变量一般通过“存取方法”（access method）来访问。其中“获取方法”（getter）用于读取变量值，而“设置方法”（setter）用于写入变量值。这个概念已经定型，并且经由“属性”这一特性而成为 Objective-C 2.0 的一部分，开发者可以令编译器自动编写与属性相关的存取方法。此特性引入了一种新的“点语法”（dot syntax），使开发者可以更为容易地依照类对象来访问存放于其中的数据。</p>
<p>3.要访问属性，可以使用“点语法“，在纯 C 中，如果想访问分配在栈上的 struct 结构体里面的成员，也需使用类似语法。编译器会吧”点语法“转换为对存取方法的调用，使用”点语法“的效果与直接调用存取方法相同。因此，使用”点语法“和直接调用存取方法之间没有丝毫差别。</p>
<p>4.属性还有更多优势。如果使用了属性的话，那么编译器就会自动编写访问这些属性所需的方法，此过程叫做”自动合成“。需要强调的是，这个过程由编译器在编译期执行，所以编辑器里看不到这些”合成方法“的源代码。除了生成方法代码之外，编译器还要自动向类中添加适当类型的实例变量，并且在属性名前面加上下划线，以此作为实例变量的名字。也可以在类的实现代码里通过 @synthesize 语法来指定实例变量的名字。</p>
<p>5.一般情况下无须修改默认的实例变量名，但是如果你不喜欢以下划线来命名实例变量，那么可以用这个办法将其改为自己想要的名字。笔者还是推荐使用默认的命名方案，因为如果所有人都坚持这套方案，那么写出来的代码大家都能看得懂。</p>
<p>6.若不想令编译器自动合成存取方法，则可以自己实现。如果你只实现了其中一个存取方法，那么另外一个还是会由编译器来合成。还有一种办法能阻止编译器自动合成存取方法，就是使用 <code>@dynamic</code> 关键字,它会告诉编译器：不要自动创建实现属性所用的实例变量，也不要为其创建存取方法。而且，在编译访问属性的代码时，即使编译器发现没有定义存取方法，也不会报错，它相信这些方法能在运行期找到。  </p>
<p>7.使用属性时还有一个问题要注意，就是其各种特质（attribute）设定也会影响编译器所生成的存取方法。属性可以拥有的特质分为 4 类：  </p>
<ul>
<li>原子性</li>
<li>读/写权限</li>
<li>内存管理语义</li>
<li>方法名</li>
</ul>
<p>8.在属性不添加任何特质时，MRC 默认情况是 <code>atomic</code>，<code>assign</code>，<code>readwrite</code>。ARC 默认情况是 <code>atomic</code>，<code>strong</code>，<code>readwrite</code>。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property BOOL checked;</div></pre></td></tr></table></figure>
<p><a href="http://stackoverflow.com/questions/5802511/what-are-the-defaults-values-for-property-in-ios" target="_blank" rel="external">http://stackoverflow.com/questions/5802511/what-are-the-defaults-values-for-property-in-ios</a><br><a href="http://www.devtalking.com/articles/you-should-to-know-property/" target="_blank" rel="external">http://www.devtalking.com/articles/you-should-to-know-property/</a>  </p>
<p>9.原子性：在默认情况下，由编译器所合成的方法会通过锁定机制确保其原子性（atomicity）。如果属性具备 nonatomic 特质，则不使用同步锁。</p>
<p>10.具备 readwrite（读写）特质的属性拥有“获取方法”（getter）与“设置方法”（setter）。</p>
<p>11.具备 readonly（只读）特质的属性仅拥有获取方法。你可以使用此特质把某个属性对外公开为只读属性，然后在“class-continuation 分类”中将其重新定义为读写属性。</p>
<p>12.<code>assign</code> 设置方法 只会执行针对 “纯量类型”（scalar type，例如 <code>CGFloat</code> 或 <code>NSInteger</code> 等）的简单赋值操作。</p>
<p>13.<code>strong</code> 此特质表明该属性定义了一种“拥有关系”（owning relationship）。为这种属性设置新值时，设置方法会先保留新值，并释放旧值，然后再将新值设置上去。</p>
<p>14.<code>weak</code> 此特质表明该属性定义了一种“非拥有关系”（nonowning relationship）。为这种属性设置新值时，设置方法既不保留新值，也不释放旧值。此特质同 <code>assign</code> 类似，然而在属性所指的对象遭到销毁时，属性值也会清空（nil out）。</p>
<p>15.<code>unsafe_unretained</code> 此特质的语义和 assign 相同，但是它适用于 对象类型，该特质表达一种 “非拥有关系”（“不保留”，unretained），当目标对象遭到销毁时，属性值不会自动清空（“不安全”，unsafe），这一点与 weak 有区别。</p>
<p>16.<code>copy</code> 此特质所表达的所属关系与 <code>strong</code> 类似。然而设置方法并不保留新值，而是将其拷贝（<code>copy</code>）。</p>
<p>17.当属性类型为 <code>NSString*</code> 时，经常用此特质来保护其封装性。因为传递给设置方法的新值有可能指向一个 NSMutableString 类的实例。这个类是 NSString 的子类，表示一种可以修改其值的字符串，此时若是不拷贝字符串，那么设置完属性之后，字符串的值就可能会在对象不知情的情况下遭人更改。所以，这时就要拷贝一份“不可变”（immutable）的字符串，确保对象中的字符串值不会无意间变动。只要实现属性所用的对象是“可变的”（mutable），就应该在设置新属性值时拷贝一份。<code>NSDictionary</code> 和 <code>NSArray</code> 也应如此。</p>
<p>18.可通过如下特质来制定存取方法的方法名：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property(nonatomic, getter=isOn) BOOL on;</div></pre></td></tr></table></figure>
<p>19.setter=<name> 指定“设置方法”的方法名。</name></p>
<p>20.通过上述特质，可以微调由编译器所合成的存取方法。不过需要注意：若是自己来实现这些存取方法，那么应该<strong>保证其具备相关属性所声明的特质</strong>。比方说，如果将某个属性声明为 copy，那么就应该在”设置方法“中拷贝相关对象，否则会误导该属性的使用者，而且，若是不遵从这一约定，还会令程序产生 bug。</p>
<p>21.由于是只读属性，所以编译器不会为其创建对应的“设置方法”，即便如此，我们还是要写上这些属性的语义，以此表明<strong>初始化方法在设置这些属性值时所用的方式</strong>。要是不写明语义的话。该类的调用者就不知道初始化方法里会拷贝这些属性，他们有可能会在调用初始化方法之前自行拷贝属性值。这种操作是多余而且低效的。</p>
<p>22.<code>atomic</code> 与 <code>nonatomic</code> 的区别</p>
<p>具备 <code>atomic</code> 特质的获取方法会通过锁定机制来保证其原子性。这也就是说，如果两个线程读写同一属性，那么不论何时，总能看到有效的属性值。若是不加锁的话（或者说使用 nonatomic 语义），那么当其中一个线程正在改写某属性值，另一个线程也许会突然闯入，把尚未修改好的属性值读取出来。发生这种情况时，线程读到的属性值可能不对。</p>
<p>23.atomic 一定是线程安全的吗？</p>
<p>如果开发过 iOS 程序，你就会发现，其中所有属性都声明为 nonatomic。这样做的历史原因是：<strong>在 iOS 中使用同步锁的开销较大，这会带来性能问题。一般情况下并不要求属性必须是“原子的”，因为这并不能保证“线程安全”（thread safety），若要实现“线程安全 ”的操作，还需采用更为深层的锁定机制才行。例如，一个线程在连续多次读取某属性值的过程中有别的线程在同时改写该值，那么即便将属性声明为 atomic，也还是会读到不同的属性值。因此，开发 iOS 程序时一般都会使用 nonatomic 属性。</strong>但是在开发Mac OS X 程序时，使用 atomic 属性通常都不会有性能瓶颈。</p>
<p>24.消息转发</p>
<p><a href="http://www.jianshu.com/p/1bde36ad9938" target="_blank" rel="external">http://www.jianshu.com/p/1bde36ad9938</a></p>
<p>25.Runtime（貌似满大街都是的文章了）</p>
<p><a href="http://www.jianshu.com/p/e071206103a4" target="_blank" rel="external">http://www.jianshu.com/p/e071206103a4</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images//effective_objectivec_2.0/1.jpg&quot; alt=&quot;1.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;0.用 Objective-C 等面向对象语言编程时，“对象”就是“基本构造单元”（building block），开发者可以通过对
    
    </summary>
    
      <category term="iOS" scheme="http://iYiming.me/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>第 1 章 熟悉 Objective-C</title>
    <link href="http://iYiming.me/2016/06/05/2016-06-05-di-1-zhang-shou-xi-objective-c/"/>
    <id>http://iYiming.me/2016/06/05/2016-06-05-di-1-zhang-shou-xi-objective-c/</id>
    <published>2016-06-05T03:08:45.000Z</published>
    <updated>2016-08-14T00:53:18.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images//effective_objectivec_2.0/1.jpg" alt="1.jpg"></p>
<p>0.若是用过另一种面向对象语言（C++ 或 Java），那么就能理解 Objective-C 所用的许多范式与模板了。然而语法上也许会显得陌生，因为该语言使用“消息结构”(messaging structure)而非“函数调用”（function calling）。Objective-C 语言由 Smalltalk 演化而来，后者是消息型语言的鼻祖。</p>
<p>1.关键区别在于：<strong>使用消息结构的语言，其运行时所应执行的代码由运行环境来决定；而使用函数调用的语言，则由编译器决定</strong>。</p>
<p>2.对 1 注解：如果范例代码中调用的函数是多态的，那么在运行时就要按照“虚方法表”（virtual table）来查出到底应该执行哪个函数实现。而采用消息结构的语言，不论是否多态，总是在运行时才会去查找索要执行的方法。实际上，编译器甚至不关心接收消息的对象是何种类型。接收消息的对象也要在运行时处理，其过程叫做“动态绑定”（dynamic binding）。</p>
<p>3.Objective-C 的重要工作都由“运行期组件”（runtime component）而非编译器来完成。使用 Objective-C 的面向对象特性所需的全部数据结构及函数都在运行期组件里面。举例来说，运行期组件中含有全部内存管理方法。<strong>运行期组件本质上就是一种与开发者所编写代码相连接的“动态库”（dynamic library），其代码能把开发者编写的所有程序粘合起来。这样的话，只需更新运行期组件，即可提升应用程序性能。</strong>而那种许多工作都在“编译期”（compile time）完成的语言，若想获得类似的性能提升，则要重新编译应用程序代码。</p>
<p>4.初始化一个字符串：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSString *someString = @&quot;The string&quot;;</div></pre></td></tr></table></figure>
<p>这种语法基本上是照搬 C 语言的。它声明了一个名为 <code>someString</code> 的变量,其类型是 <code>NSString*</code>。也就是说，此变量为指向 <code>NSString</code> 的 指针。所有 Objective-C 语言的对象都必须这样声明，因为对象所占内存总是分配在”堆空间”（heap space）中，而绝不会分配在“栈”（stack）上。</p>
<p>5.分配在堆中的内存必须直接管理，而分配在栈上用于保存变量的内存则会在其栈帧弹出时自动清理。</p>
<p>6.Objective-C 将堆内存管理抽象出来了。不需要用 <code>malloc</code> 及 <code>free</code> 来分配或释放对象所占内存。Objective-C 运行期环境就把这部分工作抽象为一套内存管理架构，名叫“引用计数”。</p>
<p>7.在 Objective-C 代码中，有时会遇到定义里不含 <code>*</code> 的变量,它们可能会使用“栈空间”（stack space）。这些变量所保存的不是 Objective-C 对象。比如 CoreGraphic 框架中的 <code>CGRect</code> 是 C 结构体。整个系统框架都在用这种结构体，因为如果改用 Objective-C 对象来做的话。</p>
<p>8.Objective-C 为 C 语言添加了面向对象特性，是其超集。Objective-C 使用动态绑定的消息结构，也就是说，在运行时才会检查对象类型。接收一条消息之后，究竟应执行何种代码，由运行期环境而非编译器来决定。</p>
<p>9.除非确有必要，否则不要引入头文件。一般来说，应在某个类的头文件中使用<strong>向前声明</strong>（如果提前声明 <code>Person</code> 类，使用：<code>@class Person;</code>）来提及别的类，并在实现文件中引入那些类的头文件。这样做可以尽量降低类之间的耦合。<strong>若引入许多根本用不到的内容，会增加编译时间</strong>。</p>
<p>10.看下面这个例子(仅列出.h文件)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">//YMPerson.h</div><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line">#import &quot;YMEmployer.h&quot;</div><div class="line"></div><div class="line">@interface YMPerson : NSObject</div><div class="line"></div><div class="line">@property (nonatomic, copy) NSString *firstName;</div><div class="line">@property (nonatomic, copy) NSString *lastName;</div><div class="line">@property (nonatomic, strong) YMEmployer *employer;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">//YMEmployer.h</div><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line">#import &quot;YMPerson.h&quot;</div><div class="line"></div><div class="line">@interface YMEmployer : NSObject</div><div class="line"></div><div class="line">- (void) addEmployee:(YMPerson *) person;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>这样会出现问题，虽然使用 <code>#import</code> 而非 <code>#include</code> 指令虽然不会导致死循环，但这却意味着两个类有一个无法被正确编译。而使用向前声明却可以解决这个问题。</p>
<p>11.有时候必须要在头文件中引入其他头文件：</p>
<ul>
<li>如果你写的类继承自某个超类，则必须引入定义那个超类的头文件。</li>
<li>如果要声明你写的类遵从某个协议，那么该协议必须有完整定义，且不能使用向前声明。向前声明只能高度编译器有某个协议，而此时编译器却要知道该协议中定义的方法。</li>
</ul>
<p>12.引入协议头文件，最好把协议单独放在一个头文件中。然而有些协议，例如“委托协议”，就不用单独写一个头文件了，在这种情况下，协议只有与接收协议委托的类放在一起定义才有意义。</p>
<p>13.每次在头文件中引入其他头文件之前，都要先问问自己这样做是否确有必要。如果可以用向前声明取代引入，那么就不要引入。若因为要实现属性。实例变量或者要遵循协议而必须引入头文件，则应尽量将其一直“ class-continuation 分类”。这样不仅可以所见编译时间，而且还能降低彼此依赖程度。若是依赖关系过于复杂，则会给维护带来麻烦，而且，如果只要把代码的某个部分开放为公共API的话，太复杂的依赖关系也会出现问题。</p>
<p>14.应该使用字面量语法来创建字符串、数值、数组、字典。与创建此类对象的常规方法相比，这么做更加简明扼要。</p>
<p>15.用字面量语法创建数组时要注意，若数组元素对象中有 <code>nil</code>，则会抛出异常，因为字面量语法实际上指示一种语法糖（ syntactic sugar ），其效果等于是先创建了一个数组，然后把方括号内的所有对象都加到这个数组中。这样会让我们提前知道错误，而使用最原始的方法虽不会抛出异常使我们不好找到异常。</p>
<p>16.字典中的对象和键必须都是 Objective-C 对象，所以不能把整数值（如 <code>10</code> ）直接放进去，而是将其封装在<code>NSNumber</code>实例中（ <code>@10</code> ）才行。</p>
<p>17.使用字面量语法创建出来的字符串、数组、字典对象都是不可变的（immutable）。若想要可变版本的对象，则需复制一份：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSMutableArray *mutable = [[@1, @2, @3] mutableCopy];</div></pre></td></tr></table></figure>
<p>18.字面量语法有个小小的限制，就是除了字符串意外，所差出来对象必须属于 Foundation 框架才行。</p>
<p>19.在编写代码时经常要定义常量。掌握了 Objective-C 与其 C 语言基础的人，也许会用这种方法来做：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#define ANIMATION_DURATION 0.3</div></pre></td></tr></table></figure>
<p>上述预处理命令会把源代码中的 <code>ANIMATION_DURATION</code> 字符串替换为 <code>0.3</code> 。这可能是你想要的效果，不过这样定义出来的常量<strong>没有类型信息</strong>。</p>
<p>20.要想解决上面的问题，应该设法利用编译器的某些特性才对。有个办法比用预处理指令来定义常量更好。比方说，下面这行代码就定义了一个类型为 <code>NSTimeInteval</code> 的常量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">static const NSTimeInterval kAnimationDuration = 0.3;</div></pre></td></tr></table></figure>
<p>这样定义的常量包含类型信息，其好处是清楚地描述了常量的含义。由此可知该常量类型为 <code>NSTimeInterval</code>,这有助于为其编写开发文档。如果要定义许多变量，那么这种方式能令稍后阅读代码的人更易理解其意图。</p>
<p>21.<strong>若常量局限于某“编译单元”（也就是“实现文件“）之内，则在前面加字母 <code>k</code>；若常量在类之外可见，则通常以类名为前缀</strong>。</p>
<p>22.若不打算公开某个常量，则应将其定义在使用该常量的实现文件里。变量一定要同时用 <code>static</code> 与 <code>const</code> 来声明。</p>
<ul>
<li>若视图修改由 <code>const</code> 修饰符所声明的变量，那么编译器就会报错。</li>
<li><code>static</code> 修饰符则意味着该变量仅在定义此变量的编译单元中可见。编译器每收到一个便一单元，就会输出一份”目标文件”。在 Objective-C 的语境下，“编译单元”一词通常指每个类的实现文件（以 <code>.m</code> 为后缀名）。假如声明此变量时不加 <code>static</code>,则编译器会为它创建一个“外部符号”（external symbol）。</li>
</ul>
<p>23.有时候需要对外公开某个常量。比方说，可能要在类代码中调用NSNotificationCenter来通知他人。用一个对象来派发通知，令其他欲接收通知的对象向该对象注册，这样就能实现此功能了。派发通知时，需要使用字符串来表示此项通知的名称，而这个名字就可以声明为一个外界可见的长值变量(constant variable)。这样的话，注册者无须知道实际字符串值，只需以常值变量来注册自己想要接收的通知即可。应该这样定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//在 .h 文件中</div><div class="line">extern NSString *const YMStringConstant;</div><div class="line"></div><div class="line">//在 .m 文件中</div><div class="line">NSString *const YMStringConstant = @&quot;Value&quot;;</div></pre></td></tr></table></figure>
<p><strong>这个常量在头文件中“声明”，且在实现文件中“定义”。注意 <code>const</code> 修饰符在常量类型中的位置。</strong></p>
<p>24.注意常量的名字。<strong>为避免名称冲突，最好是用与之相关的类名做前缀</strong>。系统框架中一般都这样做。例如 UIKit 就按照这种方式来声明用作通知名称的全局常量。其中有类似 <code>UIApplicationDidEnterBackgroundNotification</code> 与 <code>UIApplicationWillEnterForegroundNotification</code> 这样的常量名。</p>
<p>25.不要用预处理指令定义常量。这样定义出来的常量不含类型信息，编译器只是会在编译前据此执行查找与替换操作。即使有人重新定义了常量值，<strong>编译器也不会产生警告信息</strong>，这样导致应用程序中的常量值不一致。  </p>
<p>26.在实现文件中使用 <code>static const</code> 来定义”只在编译单元内可见的常量“。由于此类常量不在全局符号表中，所以无需为其名称加前缀。</p>
<p>27.在头文件中使用 <code>extern</code> 来声明全局变量，并在相关实现文件中定义其值。这种常量要出现在全局符号表中，所以其名称应加以区隔，通常用与之相关的类名称做前缀。</p>
<p>28.应该用枚举来表示状态机的状态、传递给方法的选项以及状态吗等值，给这些值起个易懂的名字。</p>
<p>29.如果把传递给某个方法的选项表示为枚举类型，而多个选项又可同时使用。那么就讲各选项值定义为 <code>2</code> 的幂，以便通过按位或操作将其组合起来。</p>
<p>30.用 <code>NS_ENUM</code> 与 <code>NS_OPTIONS</code> 宏来定义枚举类型，并指明其底层数据类型。这样做可以确保枚举是用开发者所选的底层数据类型实现出来的，而不会采用编译器所选的类型。</p>
<p>31.我们总习惯在 <code>switch</code> 语句中加上 <code>default</code> 分支。然而，若是用枚举来定义状态机，则最好不要有 <code>default</code> 分支。这样的话，如果稍后又加了一种状态，那么编译器就会发出警告信息，提示新加入的状态并未在 <code>switch</code> 分支中处理。假如写上了 <code>default</code> 分支，那么它就会处理这个新状态，从而导致编译器不发警告信息。</p>
<p>32.枚举分为：普通枚举(<code>NS_ENUM</code>) 和 选项枚举（<code>NS_OPTIONS</code>），其中选项枚举，如系统中的 <code>UIViewAutoresizing</code>，这么定义:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">typedef NS_OPTIONS(NSUInteger, UIViewAutoresizing) &#123;</div><div class="line">    UIViewAutoresizingNone                 = 0,</div><div class="line">    UIViewAutoresizingFlexibleLeftMargin   = 1 &lt;&lt; 0,</div><div class="line">    UIViewAutoresizingFlexibleWidth        = 1 &lt;&lt; 1,</div><div class="line">    UIViewAutoresizingFlexibleRightMargin  = 1 &lt;&lt; 2,</div><div class="line">    UIViewAutoresizingFlexibleTopMargin    = 1 &lt;&lt; 3,</div><div class="line">    UIViewAutoresizingFlexibleHeight       = 1 &lt;&lt; 4,</div><div class="line">    UIViewAutoresizingFlexibleBottomMargin = 1 &lt;&lt; 5</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>选项枚举的原理，见下图：</p>
<p><img src="/images//effective_objectivec_2.0/0.jpg" alt="0.jpg"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images//effective_objectivec_2.0/1.jpg&quot; alt=&quot;1.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;0.若是用过另一种面向对象语言（C++ 或 Java），那么就能理解 Objective-C 所用的许多范式与模板了。然而语法上也许
    
    </summary>
    
      <category term="iOS" scheme="http://iYiming.me/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>仿写 RSS 阅读器 Unread 下拉刷新</title>
    <link href="http://iYiming.me/2016/05/22/2016-05-22-zi-ding-yi-xia-la-shua-xin/"/>
    <id>http://iYiming.me/2016/05/22/2016-05-22-zi-ding-yi-xia-la-shua-xin/</id>
    <published>2016-05-22T02:26:20.000Z</published>
    <updated>2016-08-12T16:13:02.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>Swift 变化太快，原先敲的码已年久失修，重新整理之</p>
</blockquote>
<p>实现的效果如下：</p>
<p><img src="/images/custom_refresh_2/1.gif" alt="1"></p>
<h2 id="下拉刷新原理"><a href="#下拉刷新原理" class="headerlink" title="下拉刷新原理"></a>下拉刷新原理</h2><ul>
<li><code>UIScrollView</code> 的 <code>contentInset</code> 属性用于保持停留</li>
<li><code>UIScrollView</code> 的 <code>contentOffset</code> 属性获取偏移量。从而获取刷新状态，使用它我们就可以制定相应的自定义动画了。</li>
</ul>
<h2 id="怎样方便重用"><a href="#怎样方便重用" class="headerlink" title="怎样方便重用"></a>怎样方便重用</h2><p>如何获取偏移量？  </p>
<p>有两种方式可以获得:</p>
<ol>
<li><p>在含有 <code>UIScrollView</code>（及其子类）控制器里面使用<code>UIScrollViewDelegate</code>，从而获取偏移量。  </p>
</li>
<li><p>使用 KVO，通过监听 <code>contentOffset</code>，很容易的就得到了偏移量。</p>
</li>
</ol>
<p>但是如果要在多个控制器中使用下拉刷新，那么每个控制器都实现<code>UIScrollViewDelegate</code> 或 KVO，繁琐且臃肿。</p>
<p>滚动视图（<code>UIScrollView</code> 及其子类）和下拉刷新视图是一起的，有下拉刷新的地方就有滚动视图。把下拉刷新视图添加在滚动视图上（<code>UIScrollView</code>及其子类），得到刷新视图就可以获得滚动视图。因此把监听写在刷新视图里，就不用到处写了。</p>
<p>还有个问题，我们如何给滚动视图添加下拉刷新视图呢？有没有简单的方式给滚动视图添加下拉刷新视图。我们可以使用分类，添加一个下拉刷新视图属性，只要我们给这个下拉刷新视图赋值，我们就把它添加到滚动视图上。</p>
<h2 id="实现效果中的三个动画"><a href="#实现效果中的三个动画" class="headerlink" title="实现效果中的三个动画"></a>实现效果中的三个动画</h2><h4 id="0-展开、关闭动画"><a href="#0-展开、关闭动画" class="headerlink" title="0.展开、关闭动画"></a>0.展开、关闭动画</h4><p>原先是使用 POP 实现的，这次使用多次动画的方式。代码如下，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> 展开动画</div><div class="line"> </div><div class="line"> :param: animationLayer 动画Layer</div><div class="line"> */</div><div class="line">func spreadLayerAnimation(animationLayer: CALayer)&#123;</div><div class="line">    layerWidthAnimation(animationLayer, width: 100, animationTypeStr: &quot;Spread&quot;, animationIndexStr: &quot;1&quot;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> 关闭动画</div><div class="line"> </div><div class="line"> :param: animationLayer 关闭Layer</div><div class="line"> */</div><div class="line">func closeLayerAnimation(animationLayer: CALayer)&#123;</div><div class="line">    layerWidthAnimation(animationLayer, width: 0, animationTypeStr: &quot;Close&quot;, animationIndexStr: &quot;1&quot;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> 宽度动画</div><div class="line"> </div><div class="line"> :param: animationLayer    动画层</div><div class="line"> :param: width             宽度</div><div class="line"> :param: animationTypeStr  动画类型 展开 或 关闭</div><div class="line"> :param: animationIndexStr 动画索引</div><div class="line"> */</div><div class="line">func layerWidthAnimation(animationLayer: CALayer,width: CGFloat,animationTypeStr: String,animationIndexStr: String)&#123;</div><div class="line">    let screenWidth = CGRectGetWidth(UIScreen.mainScreen().bounds)</div><div class="line">    </div><div class="line">    let animation = CABasicAnimation(keyPath: &quot;bounds.size.width&quot;)</div><div class="line">    animation.duration = 0.13</div><div class="line">    animation.delegate = self</div><div class="line">    animation.toValue = NSNumber(float: 20)</div><div class="line">    animation.setValue(animationLayer, forKey: &quot;AnimationLayer&quot;)</div><div class="line">    animation.setValue(animationTypeStr, forKey: &quot;AnimationType&quot;)</div><div class="line">    animation.setValue(animationIndexStr, forKey: &quot;AnimationIndex&quot;)</div><div class="line">    animation.timingFunction = CAMediaTimingFunction(name: kCAMediaTimingFunctionEaseInEaseOut)</div><div class="line">    animationLayer.addAnimation(animation, forKey: &quot;animation&quot;)</div><div class="line">    animationLayer.frame = CGRect(x: (screenWidth - width)/2.0, y: animationLayer.frame.origin.y, width: CGFloat(width), height: animationLayer.frame.size.height)</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 动画结束</div><div class="line">override func animationDidStop(anim: CAAnimation, finished flag: Bool) &#123;</div><div class="line">    let animationLayer = anim.valueForKey(&quot;AnimationLayer&quot;) as! CALayer</div><div class="line">    let animationTypeStr = anim.valueForKey(&quot;AnimationType&quot;) as! String</div><div class="line">    let animationIndexStr = anim.valueForKey(&quot;AnimationIndex&quot;) as! String</div><div class="line"></div><div class="line">    var width:CGFloat = 0</div><div class="line">    if animationIndexStr == &quot;1&quot;&#123;</div><div class="line">        if animationTypeStr == &quot;Spread&quot;&#123;</div><div class="line">            width = 20</div><div class="line">        &#125;else if animationTypeStr == &quot;Close&quot;&#123;</div><div class="line">            width = 20</div><div class="line">        &#125;</div><div class="line">    &#125;else if animationIndexStr == &quot;2&quot;&#123;</div><div class="line">        if animationTypeStr == &quot;Spread&quot;&#123;</div><div class="line">            width = 80</div><div class="line">        &#125;else if animationTypeStr == &quot;Close&quot;&#123;</div><div class="line">            width = 4</div><div class="line">        &#125;</div><div class="line">    &#125;else if animationIndexStr == &quot;3&quot;&#123;</div><div class="line">        if animationTypeStr == &quot;Spread&quot;&#123;</div><div class="line">            width = 40</div><div class="line">        &#125;else if animationTypeStr == &quot;Close&quot;&#123;</div><div class="line">            return</div><div class="line">        &#125;</div><div class="line">    &#125;else if animationIndexStr == &quot;4&quot;&#123;</div><div class="line">        if animationTypeStr == &quot;Spread&quot;&#123;</div><div class="line">            width = 60</div><div class="line">        &#125;</div><div class="line">    &#125;else&#123;</div><div class="line">        return</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    layerWidthAnimation(animationLayer, width: width, animationTypeStr: animationTypeStr, animationIndexStr:String(Int(animationIndexStr)! + 1))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="1-旋转动画"><a href="#1-旋转动画" class="headerlink" title="1.旋转动画"></a>1.旋转动画</h4><p>其实就是沿着一定的路径进行旋转，使用 <code>CAKeyframeAnimation</code> 的 <code>path</code> 属性按照响应的贝塞尔曲线旋转。如下图：  </p>
<p><img src="/images/custom_refresh_2/2.gif" alt="2"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">// 设置界面</div><div class="line">func settingUI() &#123;</div><div class="line">    let screenWidth = CGRectGetWidth( UIScreen.mainScreen().bounds)</div><div class="line">    </div><div class="line">    layer1.backgroundColor = UIColor.redColor().CGColor</div><div class="line">    layer1.frame = CGRect(x: (screenWidth - 8)/2.0, y: 100, width: 8, height: 8)</div><div class="line">    layer1.cornerRadius = 4</div><div class="line">    view.layer.addSublayer(layer1)</div><div class="line">    </div><div class="line">    </div><div class="line">    layer2.backgroundColor = UIColor.redColor().CGColor</div><div class="line">    layer2.frame = CGRect(x: (screenWidth - 8)/2.0, y: 120, width: 8, height: 8)</div><div class="line">    layer2.cornerRadius = 4</div><div class="line">    view.layer.addSublayer(layer2)</div><div class="line">    </div><div class="line">    </div><div class="line">    layer3.backgroundColor = UIColor.redColor().CGColor</div><div class="line">    layer3.frame = CGRect(x: (screenWidth - 8)/2.0, y: 140, width: 8, height: 8)</div><div class="line">    layer3.cornerRadius = 4</div><div class="line">    view.layer.addSublayer(layer3)</div><div class="line">&#125;</div><div class="line"></div><div class="line">@IBAction func startAnimation(sender: AnyObject) &#123;</div><div class="line">    let screenWidth = CGRectGetWidth(UIScreen.mainScreen().bounds)</div><div class="line">    </div><div class="line">    let animation1 = CAKeyframeAnimation(keyPath: &quot;position&quot;)</div><div class="line">    animation1.delegate = self</div><div class="line">    animation1.duration = CFTimeInterval(0.3)</div><div class="line">    animation1.path = UIBezierPath(arcCenter: CGPoint(x:(screenWidth - 8)/2.0 + 4, y: 124.0),radius: CGFloat(58), startAngle:CGFloat(-M_PI_2), endAngle: CGFloat(0), clockwise: true).CGPath</div><div class="line">    animation1.timingFunction = CAMediaTimingFunction(name: kCAMediaTimingFunctionEaseInEaseOut)</div><div class="line">    layer1.addAnimation(animation1, forKey: &quot;rotationAnimation&quot;)</div><div class="line">    CATransaction.begin()</div><div class="line">    CATransaction.setDisableActions(true)</div><div class="line">    layer1.position = CGPoint(x: (screenWidth - 8)/2.0 + 58 + 4, y: 124)</div><div class="line">    CATransaction.commit()</div><div class="line">    </div><div class="line">    let animation3 = CAKeyframeAnimation(keyPath: &quot;position&quot;)</div><div class="line">    animation3.delegate = self</div><div class="line">    animation3.duration = CFTimeInterval(0.3)</div><div class="line">    animation3.path = UIBezierPath(arcCenter: CGPoint(x:(screenWidth - 8)/2.0 + 4, y: 124.0),radius: CGFloat(58), startAngle:CGFloat(M_PI_2), endAngle: CGFloat(M_PI), clockwise: true).CGPath</div><div class="line">    animation3.timingFunction = CAMediaTimingFunction(name: kCAMediaTimingFunctionEaseInEaseOut)</div><div class="line">    layer3.addAnimation(animation3, forKey: &quot;rotationAnimation&quot;)</div><div class="line">    CATransaction.begin()</div><div class="line">    CATransaction.setDisableActions(true)</div><div class="line">    layer3.position = CGPoint(x: (screenWidth - 8)/2.0 - 58 + 4, y: 124)</div><div class="line">    CATransaction.commit()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2-按顺序放大、改变颜色动画"><a href="#2-按顺序放大、改变颜色动画" class="headerlink" title="2.按顺序放大、改变颜色动画"></a>2.按顺序放大、改变颜色动画</h4><p>有三个 Layer，第一个 Layer 动画（放大、改变颜色）结束后（使用 <code>animationDidStop</code>协议方法），开始第二个动画然后依次类推。如下图：</p>
<p><img src="/images/custom_refresh_2/3.gif" alt="3"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line">var circleShapeLayer1 = CAShapeLayer()</div><div class="line">var circleShapeLayer2 = CAShapeLayer()</div><div class="line">var circleShapeLayer3 = CAShapeLayer()</div><div class="line"></div><div class="line">/**</div><div class="line"> 设置界面</div><div class="line"> */</div><div class="line">func settingUI() &#123;</div><div class="line">    let shapeWidth:CGFloat = 10</div><div class="line">    let bezierCGPath =  UIBezierPath(ovalInRect: CGRect(x: 0, y: 0, width: shapeWidth, height: shapeWidth)).CGPath</div><div class="line">    </div><div class="line">    let fillCGColor = UIColor(red: 200/255.0, green: 200/255.0, blue: 200/255.0, alpha: 1.0).CGColor</div><div class="line">    </div><div class="line">    let screenWidth = CGRectGetWidth(UIScreen.mainScreen().bounds)</div><div class="line">    let marginLeft = CGFloat((screenWidth - 70)/2.0)</div><div class="line">    </div><div class="line">    circleShapeLayer1.path = bezierCGPath</div><div class="line">    circleShapeLayer1.fillColor = fillCGColor</div><div class="line">    </div><div class="line">    circleShapeLayer1.frame = CGRect(x: marginLeft, y: 100, width: shapeWidth, height: shapeWidth)</div><div class="line">    view.layer.addSublayer(circleShapeLayer1)</div><div class="line">    </div><div class="line">    circleShapeLayer2.path = bezierCGPath</div><div class="line">    circleShapeLayer2.fillColor = fillCGColor</div><div class="line">    circleShapeLayer2.frame = CGRect(x: marginLeft + 30, y: 100, width: shapeWidth, height: shapeWidth)</div><div class="line">    view.layer.addSublayer(circleShapeLayer2)</div><div class="line">    </div><div class="line">    circleShapeLayer3.path = bezierCGPath</div><div class="line">    circleShapeLayer3.fillColor = fillCGColor</div><div class="line">    circleShapeLayer3.frame = CGRect(x: marginLeft + 60, y: 100, width: shapeWidth, height: shapeWidth)</div><div class="line">    view.layer.addSublayer(circleShapeLayer3)</div><div class="line">&#125;</div><div class="line"></div><div class="line">//开始动画</div><div class="line">@IBAction func startAnimationButtonClicked(sender: AnyObject) &#123;</div><div class="line">    addLayerAnimation(circleShapeLayer1,layerTagStr: &quot;1&quot;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> 添加图层动画</div><div class="line"> </div><div class="line"> :param: layer       图层</div><div class="line"> :param: layerTagStr 图层 Tag</div><div class="line"> */</div><div class="line">func addLayerAnimation(layer: CAShapeLayer,layerTagStr: String) &#123;</div><div class="line">    let scaleKeyframeAnimation = CAKeyframeAnimation(keyPath: &quot;transform&quot;)</div><div class="line">    </div><div class="line">    let t1 = CATransform3DMakeScale(1.0, 1.0, 0)</div><div class="line">    let t2 = CATransform3DMakeScale(1.5, 1.5, 0)</div><div class="line">    let t3 = CATransform3DMakeScale(1.0, 1.0, 0)</div><div class="line">    </div><div class="line">    scaleKeyframeAnimation.values = [NSValue(CATransform3D:t1),NSValue(CATransform3D:t2),NSValue(CATransform3D:t3)]</div><div class="line">    scaleKeyframeAnimation.keyTimes = [0, 0.5, 1]</div><div class="line">    </div><div class="line">    let normalCGColor = UIColor(red: 200/255.0, green: 200/255.0, blue: 200/255.0, alpha: 1.0).CGColor</div><div class="line">    let highlightedColor = UIColor(red: 60/255.0, green: 60/255.0, blue: 60/255.0, alpha: 1.0).CGColor</div><div class="line">    let colorKeyframeAnimation = CAKeyframeAnimation(keyPath: &quot;fillColor&quot;)</div><div class="line">    colorKeyframeAnimation.values = [normalCGColor,highlightedColor,normalCGColor]</div><div class="line">    colorKeyframeAnimation.keyTimes = [0, 0.5, 1]</div><div class="line">    </div><div class="line">    let groupAnimation = CAAnimationGroup()</div><div class="line">    groupAnimation.duration = CFTimeInterval(0.35)</div><div class="line">    groupAnimation.animations = [scaleKeyframeAnimation,colorKeyframeAnimation]</div><div class="line">    groupAnimation.removedOnCompletion = true</div><div class="line">    groupAnimation.setValue(layerTagStr, forKey: &quot;LayerTag&quot;)</div><div class="line">    groupAnimation.delegate = self</div><div class="line">    </div><div class="line">    layer.addAnimation(groupAnimation, forKey: &quot;scaleKeyframeAnimation&quot;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 动画结束协议</div><div class="line">override func animationDidStop(anim: CAAnimation, finished flag: Bool) &#123;</div><div class="line">    let  layerTagStr = anim.valueForKey(&quot;LayerTag&quot;) as! String</div><div class="line">    </div><div class="line">    if layerTagStr == &quot;1&quot;&#123;</div><div class="line">        addLayerAnimation(circleShapeLayer2,layerTagStr: &quot;2&quot;)</div><div class="line">    &#125;else if layerTagStr == &quot;2&quot;&#123;</div><div class="line">        addLayerAnimation(circleShapeLayer3,layerTagStr: &quot;3&quot;)</div><div class="line">    &#125;else if layerTagStr == &quot;3&quot;&#123;</div><div class="line">        addLayerAnimation(circleShapeLayer1,layerTagStr: &quot;1&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码已传至GitHub：<a href="https://github.com/iYiming/YMRefreshView" target="_blank" rel="external">https://github.com/iYiming/YMRefreshView</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Swift 变化太快，原先敲的码已年久失修，重新整理之&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;实现的效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/custom_refresh_2/1.gif&quot; alt=&quot;1&quot;&gt;&lt;/p&gt;
&lt;h2 
    
    </summary>
    
      <category term="iOS" scheme="http://iYiming.me/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>写一个简易视频播放器</title>
    <link href="http://iYiming.me/2016/05/08/2016-05-08-xie-yi-ge-jian-yi-shi-pin-bo-fang-qi/"/>
    <id>http://iYiming.me/2016/05/08/2016-05-08-xie-yi-ge-jian-yi-shi-pin-bo-fang-qi/</id>
    <published>2016-05-08T15:27:57.000Z</published>
    <updated>2016-08-14T00:54:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>周末抽时间写了个视频播放器，学习使用 Sketch，画了几个图标。实现功能如下：</p>
<ul>
<li>手势调节视频进度</li>
<li>手势调节视频亮度</li>
<li>手势调节音量</li>
</ul>
<p>实现效果图：</p>
<p><img src="/images/VideoPlayer/0.png" alt="/images/VideoPlayer"></p>
<p>废话少说，直接上代码：</p>
<h3 id="0-初始化一个视频播放器"><a href="#0-初始化一个视频播放器" class="headerlink" title="0.初始化一个视频播放器"></a>0.初始化一个视频播放器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">private lazy var player: AVPlayer = &#123;</div><div class="line">   let asset = AVURLAsset(URL: self.URL)</div><div class="line">   let playerItem = AVPlayerItem(asset: asset)</div><div class="line">   var player = AVPlayer(playerItem: playerItem)</div><div class="line">        </div><div class="line">   let vol = AVAudioSession.sharedInstance().outputVolume</div><div class="line">   player.volume = 20.0 * log10f(vol + FLT_MIN)</div><div class="line">   self.startVolume =  player.volume;</div><div class="line">        </div><div class="line">   return player</div><div class="line">&#125;()</div><div class="line"></div><div class="line">let playerLayer = AVPlayerLayer(player: player)</div><div class="line">playerLayer.frame = self.bounds</div><div class="line">self.layer.addSublayer(playerLayer)</div></pre></td></tr></table></figure>
<h3 id="1-添加监听属性"><a href="#1-添加监听属性" class="headerlink" title="1.添加监听属性"></a>1.添加监听属性</h3><p>监听的属性有：  </p>
<ul>
<li>播放进度</li>
<li>音量</li>
<li>亮度</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">dynamic private var brightness: Float = 1 // 亮度</div><div class="line">dynamic private var volume: Float = 1  // 音量</div><div class="line">dynamic private var progress: Float = 1 // 播放进度</div><div class="line"></div><div class="line">func addObserver() &#123;  </div><div class="line">   // 添加视频播放进度监听</div><div class="line">   player.addPeriodicTimeObserverForInterval(CMTimeMakeWithSeconds(1.0,Int32(NSEC_PER_SEC)), queue: nil, usingBlock: &#123; (time) in</div><div class="line">        let doneTime = CMTimeGetSeconds(time)</div><div class="line">        let undoneTime = self.totalDuration - doneTime</div><div class="line">            </div><div class="line">        self.configView.progressView.beginTime = doneTime</div><div class="line">        self.configView.progressView.endTime = undoneTime</div><div class="line">        self.configView.progressView.progress = doneTime/self.totalDuration</div><div class="line">    &#125;)</div><div class="line">        </div><div class="line">    // 亮度</div><div class="line">    self.addObserver(self, forKeyPath: &quot;brightness&quot;, options: .New, context: nil)</div><div class="line">    // 音量</div><div class="line">    self.addObserver(self, forKeyPath: &quot;volume&quot;, options: .New, context: nil)</div><div class="line">    // 播放进度</div><div class="line">    self.addObserver(self, forKeyPath: &quot;progress&quot;, options: .New, context: nil)</div><div class="line">&#125;</div><div class="line">    </div><div class="line">// 移除监听</div><div class="line">func removeObserver() &#123;</div><div class="line">    self.removeObserver(self, forKeyPath: &quot;brightness&quot;)</div><div class="line">    self.removeObserver(self, forKeyPath: &quot;volume&quot;)</div><div class="line">    self.removeObserver(self, forKeyPath: &quot;progress&quot;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">override func observeValueForKeyPath(keyPath: String?, ofObject object: AnyObject?, change: [String : AnyObject]?, context: UnsafeMutablePointer&lt;Void&gt;) &#123;</div><div class="line">    if keyPath == &quot;brightness&quot; &#123; // 亮度</div><div class="line">        let brightnessValue = change![&quot;new&quot;] as! CGFloat</div><div class="line">        </div><div class="line">        self.configView.lightView.progress = brightnessValue</div><div class="line">    &#125; else if keyPath == &quot;volume&quot; &#123; // 音量</div><div class="line">        let volumeValue = change![&quot;new&quot;] as! Float</div><div class="line">        player.volume = volumeValue</div><div class="line">        configView.volumeView.progress = CGFloat(volumeValue)</div><div class="line">    &#125; else if keyPath == &quot;progress&quot; &#123; // 播放进度</div><div class="line">        let progressValue = change![&quot;new&quot;] as! Float</div><div class="line">        let dragedSeconds = floorf(Float(totalDuration) * progressValue);</div><div class="line">        let newCMTime = CMTimeMake(Int64(dragedSeconds),1);</div><div class="line">        player.seekToTime(newCMTime)</div><div class="line">        player.play()</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-手势实现调节播放进度、亮度、音量"><a href="#2-手势实现调节播放进度、亮度、音量" class="headerlink" title="2.手势实现调节播放进度、亮度、音量"></a>2.手势实现调节播放进度、亮度、音量</h3><p>建一个配置类型枚举：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public enum VideoPlayerConfigType &#123;</div><div class="line">    case None</div><div class="line">    case Volume // 调节音量</div><div class="line">    case Brightness // 调节亮度</div><div class="line">    case Progress // 调节进度</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>设置 <code>touchesBegan</code> 方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">override func touchesBegan(touches: Set&lt;UITouch&gt;, withEvent event: UIEvent?) &#123;</div><div class="line">    guard event?.allTouches()?.count == 1 else &#123; // 一个手指</div><div class="line">        return</div><div class="line">    &#125;    </div><div class="line">    </div><div class="line">    let touch = touches.first </div><div class="line">    let location = touch?.locationInView(self)</div><div class="line">        </div><div class="line">    configType = .None // 配置类型</div><div class="line">    startLocation = location! // 开始位置</div><div class="line">    </div><div class="line">    // 起始进度</div><div class="line">    startProgress =  CMTimeGetSeconds(player.currentItem!.currentTime()) / totalDuration</div><div class="line">    // 起始亮度</div><div class="line">    startBrightness = Float(UIScreen.mainScreen().brightness)</div><div class="line">    // 起始音量 （后续会改为系统音量设置）</div><div class="line">    startVolume = player.volume</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>设置 <code>touchesMoved</code> 方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line">override func touchesMoved(touches: Set&lt;UITouch&gt;, withEvent event: UIEvent?) &#123;</div><div class="line">    guard event?.allTouches()?.count == 1 else &#123;</div><div class="line">        return</div><div class="line">    &#125;</div><div class="line">        </div><div class="line">    let touch = touches.first</div><div class="line">    let location = touch?.locationInView(self)</div><div class="line">        </div><div class="line">    let changeY = location!.y - startLocation.y;</div><div class="line">    let changeX = location!.x - startLocation.x;</div><div class="line">        </div><div class="line">    if configType == .None &#123;</div><div class="line">        if fabs(changeX) &gt; fabs(changeY) &#123; // 左右滑动</div><div class="line">            configType = .Progress</div><div class="line">        &#125; else if fabs(changeY) &gt; fabs(changeX) &#123; // 上下滑动</div><div class="line">            let screenWidth = CGRectGetHeight(UIScreen.mainScreen().bounds)</div><div class="line">            if location!.x &gt;= screenWidth/2.0 &#123; // 屏幕右侧滑动</div><div class="line">                configType = .Volume</div><div class="line">                startVolume = player.volume</div><div class="line">            &#125; else &#123; // 屏幕左侧滑动</div><div class="line">                configType = .Brightness</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if configType == .Volume &#123; // 音量</div><div class="line">        let yOffset = (Float(startLocation.y - (location?.y)!))/100;</div><div class="line">            </div><div class="line">        if (startVolume + yOffset) &gt; 1 &#123; // 音量 &gt; 1 设置为 1</div><div class="line">            startLocation = location!</div><div class="line">                </div><div class="line">            startVolume = 1</div><div class="line">            volume = 1</div><div class="line">        &#125; else if (startVolume + yOffset) &lt; 0 &#123; // 音量 &lt; 0 设置为 0</div><div class="line">            startLocation = location!</div><div class="line">                </div><div class="line">            startVolume = 0</div><div class="line">            volume = 0</div><div class="line">        &#125; else &#123; // 正常范围</div><div class="line">            volume = startVolume + yOffset</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        print(&quot;音量: \(volume)&quot;);</div><div class="line">    &#125; else if configType == .Brightness &#123; // 亮度</div><div class="line">        let yOffset = (Float(startLocation.y - (location?.y)!))/100;</div><div class="line">            </div><div class="line">        if (startBrightness + yOffset) &gt; 1 &#123; // 亮度 &gt; 1 设置为 1</div><div class="line">            startLocation = location!</div><div class="line">                </div><div class="line">            brightness = 1;</div><div class="line">            startBrightness = 1</div><div class="line">        &#125; else if (startBrightness + yOffset) &lt; 0 &#123; // 亮度 &lt; 0 设置为 0</div><div class="line">            startLocation = location!</div><div class="line">                </div><div class="line">            brightness = 0;</div><div class="line">            startBrightness = 0</div><div class="line">        &#125; else &#123; // 正常范围</div><div class="line">            brightness = startBrightness + yOffset</div><div class="line">        &#125;</div><div class="line">            </div><div class="line">        print(&quot;亮度: \(brightness)&quot;);</div><div class="line">    &#125; else if configType == .Progress &#123; // 进度</div><div class="line">        let screenHeight = CGRectGetHeight(UIScreen.mainScreen().bounds)</div><div class="line">        let xOffset = (Double((location?.x)! - startLocation.x))/Double(screenHeight);</div><div class="line">            </div><div class="line">        if (startProgress + xOffset) &gt; 1 &#123; // 播放进度 &gt; 1 设置为 1</div><div class="line">            startLocation = location!</div><div class="line">                </div><div class="line">            startProgress = 1</div><div class="line">            progress = 1</div><div class="line">        &#125; else if (startProgress + xOffset) &lt; 0 &#123; // 播放进度 &lt; 0 设置为 0</div><div class="line">            startLocation = location!</div><div class="line">                </div><div class="line">            startProgress = 0</div><div class="line">            progress = 0</div><div class="line">        &#125; else &#123; // 正常进度</div><div class="line">            progress = Float(startProgress + xOffset)</div><div class="line">        &#125;</div><div class="line">            </div><div class="line">        print(&quot;进度 \(startProgress + xOffset)&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-亮度视图（音量视图、进度视图类似）"><a href="#3-亮度视图（音量视图、进度视图类似）" class="headerlink" title="3.亮度视图（音量视图、进度视图类似）"></a>3.亮度视图（音量视图、进度视图类似）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line">class LightView: UIView &#123;</div><div class="line">    dynamic var progress: CGFloat = 0.0 // 进度</div><div class="line">    </div><div class="line">    override init(frame: CGRect) &#123;</div><div class="line">        super.init(frame: frame)</div><div class="line">        </div><div class="line">        self.addObserver()</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    required init?(coder aDecoder: NSCoder) &#123;</div><div class="line">        super.init(coder: aDecoder)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    deinit &#123;</div><div class="line">        self.removeObserver()</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    func addObserver() &#123;</div><div class="line">        self.addObserver(self, forKeyPath: &quot;progress&quot;, options: .New, context: nil)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    func removeObserver() &#123;</div><div class="line">        self.removeObserver(self, forKeyPath: &quot;progress&quot;)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // 配置界面 使用 frame 实现</div><div class="line">    func configUI() &#123;</div><div class="line">        let lightIncreaseImage = UIImage.init(named: &quot;Light_Increase&quot;)!</div><div class="line">        let lightIncreaseImageSize = lightIncreaseImage.size</div><div class="line">        let lightIncreaseImageView = UIImageView.init(image: lightIncreaseImage)</div><div class="line">        lightIncreaseImageView.frame = CGRect(x: (self.frame.width - lightIncreaseImageSize.width)/2.0, y: 0, width: lightIncreaseImageSize.width, height: lightIncreaseImageSize.height)</div><div class="line">        self.addSubview(lightIncreaseImageView)</div><div class="line">        </div><div class="line">        self.layer.addSublayer(undoneLayer)</div><div class="line">        self.layer.addSublayer(doneLayer)</div><div class="line">        </div><div class="line">        let lightDecreaseImage = UIImage.init(named: &quot;Light_Decrease&quot;)!</div><div class="line">        let lightDecreaseImageSize = lightDecreaseImage.size</div><div class="line">        let lightDecreaseImageView = UIImageView.init(image: lightDecreaseImage)</div><div class="line">        lightDecreaseImageView.frame = CGRect(x: (self.frame.width - lightDecreaseImageSize.width)/2.0, y: self.frame.height - lightDecreaseImageSize.height, width: lightDecreaseImageSize.width, height: lightDecreaseImageSize.height)</div><div class="line">        self.addSubview(lightDecreaseImageView)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // 未设置的亮度 Layer</div><div class="line">    private lazy var undoneLayer: CALayer = &#123;</div><div class="line">        var undoneLayer = CALayer()</div><div class="line">        undoneLayer.frame = CGRectMake((self.frame.width - 4)/2.0, (self.frame.height - 140)/2.0, 4, 140)</div><div class="line">        undoneLayer.backgroundColor = UIColor.init(white: 1, alpha: 0.2).CGColor</div><div class="line">        return undoneLayer</div><div class="line">    &#125;()</div><div class="line">    </div><div class="line">    // 已经设置的亮度 Layer 比 未设置的亮度 Layer 白一点</div><div class="line">    private lazy var doneLayer: CALayer = &#123;</div><div class="line">        var doneLayer = CALayer()</div><div class="line">        doneLayer.frame = CGRectMake((self.frame.width - 4)/2.0, (self.frame.height - 140)/2.0 + 100, 4, 40)</div><div class="line">        doneLayer.backgroundColor = UIColor.init(white: 1, alpha: 0.6).CGColor</div><div class="line">        return doneLayer</div><div class="line">    &#125;()</div><div class="line">    </div><div class="line">    override func observeValueForKeyPath(keyPath: String?, ofObject object: AnyObject?, change: [String : AnyObject]?, context: UnsafeMutablePointer&lt;Void&gt;) &#123;</div><div class="line">        if keyPath == &quot;progress&quot; &#123;</div><div class="line">            let doneValue = change![&quot;new&quot;] as! CGFloat</div><div class="line">            let progress = doneValue * 140</div><div class="line">            UIScreen.mainScreen().brightness = doneValue // 设置屏幕亮度</div><div class="line">            doneLayer.frame = CGRectMake((self.frame.width - 4)/2.0, (self.frame.height - 140)/2.0 + (140 - progress), 4, progress)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>功能还有待完善，后续会优化及添加一些其他功能：</p>
<ul>
<li>使用 Auto Layout 进行布局</li>
<li>双击暂停等更多手势添加</li>
<li>视频导入（WiFi、iTunes）</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;周末抽时间写了个视频播放器，学习使用 Sketch，画了几个图标。实现功能如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;手势调节视频进度&lt;/li&gt;
&lt;li&gt;手势调节视频亮度&lt;/li&gt;
&lt;li&gt;手势调节音量&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;实现效果图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/i
    
    </summary>
    
      <category term="iOS" scheme="http://iYiming.me/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>阅读 SDWebImage 源码（三）</title>
    <link href="http://iYiming.me/2016/04/24/2016-04-24-sdwebimage-3/"/>
    <id>http://iYiming.me/2016/04/24/2016-04-24-sdwebimage-3/</id>
    <published>2016-04-24T04:59:08.000Z</published>
    <updated>2016-08-14T00:56:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文接 <a href="/blog/2016/04/24/sdwebimage-2/">阅读 SDWebImage 源码（二）</a> ，本篇阅读 <code>SDWebImageDownloaderOperation</code> 里面的源码。  </p>
<p>它主要负责图片的下载操作。在 <a href="/blog/2016/04/24/sdwebimage-1/">SDWebImage 源码（一）</a> 介绍中，它在 <code>SDWebImageDownloader</code> 里使用。</p>
<p><code>SDWebImageDownloaderOperation</code>，是 <code>NSOperation</code> 的子类，并发操作。结合 <code>NSURLConnection</code> 进行网络请求。</p>
<h2 id="自定义并发操作"><a href="#自定义并发操作" class="headerlink" title="自定义并发操作"></a>自定义并发操作</h2><ul>
<li>重写 <code>start</code> 方法</li>
<li><code>isConcurrent</code> 是否并发。返回 <code>YES</code></li>
<li><code>isExecuting</code> 是否正在执行 KVO</li>
<li><code>isFinish</code> 是否完成 KVO</li>
</ul>
<p><code>SDWebImageDownloaderOperation</code> 就是很好的 Demo。</p>
<h2 id="Start-方法"><a href="#Start-方法" class="headerlink" title="Start 方法"></a>Start 方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div></pre></td><td class="code"><pre><div class="line">// SDWebImageDownloaderOperation.m</div><div class="line"></div><div class="line">- (void)start &#123;</div><div class="line">    @synchronized (self) &#123;</div><div class="line">        if (self.isCancelled) &#123;</div><div class="line">            self.finished = YES;</div><div class="line">            [self reset];</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">// 0</div><div class="line">#if TARGET_OS_IPHONE &amp;&amp; __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= __IPHONE_4_0</div><div class="line">        Class UIApplicationClass = NSClassFromString(@&quot;UIApplication&quot;);</div><div class="line">        BOOL hasApplication = UIApplicationClass &amp;&amp; [UIApplicationClass respondsToSelector:@selector(sharedApplication)];</div><div class="line">        if (hasApplication &amp;&amp; [self shouldContinueWhenAppEntersBackground]) &#123;</div><div class="line">            __weak __typeof__ (self) wself = self;</div><div class="line">            UIApplication * app = [UIApplicationClass performSelector:@selector(sharedApplication)];</div><div class="line">            self.backgroundTaskId = [app beginBackgroundTaskWithExpirationHandler:^&#123;</div><div class="line">                __strong __typeof (wself) sself = wself;</div><div class="line"></div><div class="line">                if (sself) &#123;</div><div class="line">                    [sself cancel];</div><div class="line"></div><div class="line">                    [app endBackgroundTask:sself.backgroundTaskId];</div><div class="line">                    sself.backgroundTaskId = UIBackgroundTaskInvalid;</div><div class="line">                &#125;</div><div class="line">            &#125;];</div><div class="line">        &#125;</div><div class="line">#endif</div><div class="line"></div><div class="line">        self.executing = YES;</div><div class="line">        self.connection = [[NSURLConnection alloc] initWithRequest:self.request delegate:self startImmediately:NO]; // 1</div><div class="line">        self.thread = [NSThread currentThread];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    [self.connection start];</div><div class="line"></div><div class="line">    if (self.connection) &#123;</div><div class="line">        if (self.progressBlock) &#123;</div><div class="line">            self.progressBlock(0, NSURLResponseUnknownLength);</div><div class="line">        &#125;</div><div class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">            [[NSNotificationCenter defaultCenter] postNotificationName:SDWebImageDownloadStartNotification object:self];</div><div class="line">        &#125;);</div><div class="line">        </div><div class="line">        // 2</div><div class="line">        if (floor(NSFoundationVersionNumber) &lt;= NSFoundationVersionNumber_iOS_5_1) &#123;</div><div class="line">            // Make sure to run the runloop in our background thread so it can process downloaded data</div><div class="line">            // Note: we use a timeout to work around an issue with NSURLConnection cancel under iOS 5</div><div class="line">            //       not waking up the runloop, leading to dead threads (see https://github.com/rs/SDWebImage/issues/466)</div><div class="line">            CFRunLoopRunInMode(kCFRunLoopDefaultMode, 10, false);</div><div class="line">        &#125;</div><div class="line">        else &#123;</div><div class="line">            CFRunLoopRun();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (!self.isFinished) &#123;</div><div class="line">            [self.connection cancel];</div><div class="line">            [self connection:self.connection didFailWithError:[NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorTimedOut userInfo:@&#123;NSURLErrorFailingURLErrorKey : self.request.URL&#125;]];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    else &#123;</div><div class="line">        if (self.completedBlock) &#123;</div><div class="line">            self.completedBlock(nil, nil, [NSError errorWithDomain:NSURLErrorDomain code:0 userInfo:@&#123;NSLocalizedDescriptionKey : @&quot;Connection can&apos;t be initialized&quot;&#125;], YES);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">// 3</div><div class="line">#if TARGET_OS_IPHONE &amp;&amp; __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= __IPHONE_4_0</div><div class="line">    Class UIApplicationClass = NSClassFromString(@&quot;UIApplication&quot;);</div><div class="line">    if(!UIApplicationClass || ![UIApplicationClass respondsToSelector:@selector(sharedApplication)]) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    if (self.backgroundTaskId != UIBackgroundTaskInvalid) &#123;</div><div class="line">        UIApplication * app = [UIApplication performSelector:@selector(sharedApplication)];</div><div class="line">        [app endBackgroundTask:self.backgroundTaskId];</div><div class="line">        self.backgroundTaskId = UIBackgroundTaskInvalid;</div><div class="line">    &#125;</div><div class="line">#endif</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>0.开启后台下载  </p>
<p>1.使用 <code>NSURLConnection</code> 进行网络请求</p>
<p>2.开启 Run Loop。使 <code>NSURLConnection</code> 正常使用</p>
<p>3.关闭后台下载</p>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>关于 <code>NSURLConnectionDataDelegate</code> 具体使用，这里不再陈述。列几点其他代码：</p>
<ul>
<li><p>在 <code>- (void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response</code> 方法中，通过 <code>[((NSHTTPURLResponse *)response) statusCode]</code> 获取 HTTP 状态码。对于常见的 <a href="https://zh.wikipedia.org/zh-cn/HTTP%E7%8A%B6%E6%80%81%E7%A0%81" target="_blank" rel="external">HTTP 状态码</a>，我们需要熟知。这里状态码 <code>304</code> 是指图片没有被修改。</p>
</li>
<li><p>SDWebImage 都是将图片解码过程放在子线程中进行处理。不论是前面的 <code>ioQueue</code> 还是这里的 <code>Operation</code>。</p>
</li>
<li><p>最后由 <code>SDWebImageDownloaderOperation</code> 创建的 <code>operation</code> 放到了<br><code>SDWebImageDownloader</code> 队列里,这个队列默认最大并发量为 <code>6</code>。</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文接 &lt;a href=&quot;/blog/2016/04/24/sdwebimage-2/&quot;&gt;阅读 SDWebImage 源码（二）&lt;/a&gt; ，本篇阅读 &lt;code&gt;SDWebImageDownloaderOperation&lt;/code&gt; 里面的源码。  &lt;/p&gt;
&lt;p&gt;它主要
    
    </summary>
    
      <category term="iOS" scheme="http://iYiming.me/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>阅读 SDWebImage 源码（二）</title>
    <link href="http://iYiming.me/2016/04/24/2016-04-24-sdwebimage-2/"/>
    <id>http://iYiming.me/2016/04/24/2016-04-24-sdwebimage-2/</id>
    <published>2016-04-24T04:59:04.000Z</published>
    <updated>2016-08-14T00:57:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文接 <a href="/blog/2016/04/24/sdwebimage-1/">SDWebImage 源码（一）</a> ，本篇阅读 <code>SDImageCache</code> 里面的源码。  </p>
<p>它主要负责图片缓存的存取操作。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// SDImageCache.m</div><div class="line"></div><div class="line">- (NSOperation *)queryDiskCacheForKey:(NSString *)key done:(SDWebImageQueryCompletedBlock)doneBlock;</div></pre></td></tr></table></figure>
<p>上文中大体说了下这个方法内部操作，现在我们详细看一下内部实现。</p>
<h2 id="取出在内存中的图片"><a href="#取出在内存中的图片" class="headerlink" title="取出在内存中的图片"></a>取出在内存中的图片</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// SDImageCache.m </div><div class="line"></div><div class="line">- (UIImage *)imageFromMemoryCacheForKey:(NSString *)key &#123;</div><div class="line">    return [self.memCache objectForKey:key]; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>0.<code>memCache</code> 是 <code>AutoPurgeCache</code> 实例，<code>AutoPurgeCache</code> 是  <code>NSCache</code> 子类（<code>AutoPurgeCache</code> 仅多了注册了 <code>UIApplicationDidReceiveMemoryWarningNotification</code> 应用内存警告通知）。根据 key （图片 URL 字符串）取出内存中存储的图片数据。</p>
<h2 id="取出在磁盘中的图片"><a href="#取出在磁盘中的图片" class="headerlink" title="取出在磁盘中的图片"></a>取出在磁盘中的图片</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">// SDImageCache.m</div><div class="line"></div><div class="line">- (UIImage *)diskImageForKey:(NSString *)key &#123;</div><div class="line">    NSData *data = [self diskImageDataBySearchingAllPathsForKey:key]; // 0</div><div class="line">    if (data) &#123;</div><div class="line">        UIImage *image = [UIImage sd_imageWithData:data]; // 1</div><div class="line">        image = [self scaledImageForKey:key image:image]; // 2</div><div class="line">        if (self.shouldDecompressImages) &#123;</div><div class="line">            image = [UIImage decodedImageWithImage:image]; // 3</div><div class="line">        &#125;</div><div class="line">        return image;</div><div class="line">    &#125;</div><div class="line">    else &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSData *)diskImageDataBySearchingAllPathsForKey:(NSString *)key &#123;</div><div class="line">    NSString *defaultPath = [self defaultCachePathForKey:key];</div><div class="line">    NSData *data = [NSData dataWithContentsOfFile:defaultPath]; // 4</div><div class="line">    if (data) &#123;</div><div class="line">        return data;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // fallback because of https://github.com/rs/SDWebImage/pull/976 that added the extension to the disk file name</div><div class="line">    // checking the key with and without the extension</div><div class="line">    data = [NSData dataWithContentsOfFile:[defaultPath stringByDeletingPathExtension]]; // 4</div><div class="line">    if (data) &#123;</div><div class="line">        return data;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    NSArray *customPaths = [self.customPaths copy];</div><div class="line">    for (NSString *path in customPaths) &#123;</div><div class="line">        NSString *filePath = [self cachePathForKey:key inPath:path];</div><div class="line">        NSData *imageData = [NSData dataWithContentsOfFile:filePath]; // 4</div><div class="line">        if (imageData) &#123;</div><div class="line">            return imageData;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // fallback because of https://github.com/rs/SDWebImage/pull/976 that added the extension to the disk file name</div><div class="line">        // checking the key with and without the extension</div><div class="line">        imageData = [NSData dataWithContentsOfFile:[filePath stringByDeletingPathExtension]]; // 4</div><div class="line">        if (imageData) &#123;</div><div class="line">            return imageData;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return nil;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>注意：上述方法都是在 异步串行 队列中解码图片</strong></p>
<p>0.从 <code>- (NSData *)diskImageDataBySearchingAllPathsForKey:(NSString *)key;</code> 方法中获取图片数据 见 4</p>
<p>1.将 <code>NSData</code> 转化为 <code>UIImage</code>。里面区分了几种图片类型（Gif、WebP、其它）进行相应处理，为解码的图片添加方向、动态显示等。  </p>
<p>2.缩放图片。非动态图片，如果图片有后缀如 <code>@2x.</code>，<code>@3x.</code>，按照相应的比例来处理。如果没有，按照当前设备屏幕比例 Scale 来处理。处理方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">UIImage *scaledImage = [[UIImage alloc] initWithCGImage:image.CGImage scale:scale orientation:image.imageOrientation];</div></pre></td></tr></table></figure>
<p>3.解码图片。对于非动态图片，无 alpha layer 的添加上 alpha layer。（为什么这么做，还不太清楚）</p>
<p>4.根据图片 URL 字符串找到图片文件路径，从文件中获取图片数据。</p>
<h2 id="存储图片"><a href="#存储图片" class="headerlink" title="存储图片"></a>存储图片</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line">// SDImageCache.m</div><div class="line"></div><div class="line">- (void)storeImage:(UIImage *)image recalculateFromImage:(BOOL)recalculate imageData:(NSData *)imageData forKey:(NSString *)key toDisk:(BOOL)toDisk &#123;</div><div class="line">    if (!image || !key) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    // if memory cache is enabled</div><div class="line">    if (self.shouldCacheImagesInMemory) &#123;</div><div class="line">    	 // 0</div><div class="line">        NSUInteger cost = SDCacheCostForImage(image);</div><div class="line">        [self.memCache setObject:image forKey:key cost:cost];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (toDisk) &#123;</div><div class="line">        dispatch_async(self.ioQueue, ^&#123; // 1</div><div class="line">            NSData *data = imageData;</div><div class="line">            // 2</div><div class="line">            if (image &amp;&amp; (recalculate || !data)) &#123;</div><div class="line">#if TARGET_OS_IPHONE</div><div class="line">                // We need to determine if the image is a PNG or a JPEG</div><div class="line">                // PNGs are easier to detect because they have a unique signature (http://www.w3.org/TR/PNG-Structure.html)</div><div class="line">                // The first eight bytes of a PNG file always contain the following (decimal) values:</div><div class="line">                // 137 80 78 71 13 10 26 10</div><div class="line"></div><div class="line">                // If the imageData is nil (i.e. if trying to save a UIImage directly or the image was transformed on download)</div><div class="line">                // and the image has an alpha channel, we will consider it PNG to avoid losing the transparency</div><div class="line">                int alphaInfo = CGImageGetAlphaInfo(image.CGImage);</div><div class="line">                BOOL hasAlpha = !(alphaInfo == kCGImageAlphaNone ||</div><div class="line">                                  alphaInfo == kCGImageAlphaNoneSkipFirst ||</div><div class="line">                                  alphaInfo == kCGImageAlphaNoneSkipLast);</div><div class="line">                BOOL imageIsPng = hasAlpha;</div><div class="line"></div><div class="line">                // But if we have an image data, we will look at the preffix</div><div class="line">                if ([imageData length] &gt;= [kPNGSignatureData length]) &#123;</div><div class="line">                    imageIsPng = ImageDataHasPNGPreffix(imageData);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                if (imageIsPng) &#123;</div><div class="line">                    data = UIImagePNGRepresentation(image);</div><div class="line">                &#125;</div><div class="line">                else &#123;</div><div class="line">                    data = UIImageJPEGRepresentation(image, (CGFloat)1.0);</div><div class="line">                &#125;</div><div class="line">#else</div><div class="line">                data = [NSBitmapImageRep representationOfImageRepsInArray:image.representations usingType: NSJPEGFileType properties:nil];</div><div class="line">#endif</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if (data) &#123;</div><div class="line">                if (![_fileManager fileExistsAtPath:_diskCachePath]) &#123;</div><div class="line">                    [_fileManager createDirectoryAtPath:_diskCachePath withIntermediateDirectories:YES attributes:nil error:NULL];</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                // get cache Path for image key</div><div class="line">                NSString *cachePathForKey = [self defaultCachePathForKey:key];</div><div class="line">                // transform to NSUrl</div><div class="line">                NSURL *fileURL = [NSURL fileURLWithPath:cachePathForKey];</div><div class="line"></div><div class="line">                [_fileManager createFileAtPath:cachePathForKey contents:data attributes:nil];</div><div class="line"></div><div class="line">                // disable iCloud backup</div><div class="line">                if (self.shouldDisableiCloud) &#123;</div><div class="line">                    [fileURL setResourceValue:[NSNumber numberWithBool:YES] forKey:NSURLIsExcludedFromBackupKey error:nil]; // 3</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>0.缓存到内存。<code>cost</code> 一般指对象字节数。如果不知道直接传 <code>0</code>，或者是直接使用 <code>[self.memCache setObject:image forKey:key]</code>。SDWebImage 内部是这么计算的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">FOUNDATION_STATIC_INLINE NSUInteger SDCacheCostForImage(UIImage *image) &#123;</div><div class="line">    return image.size.height * image.size.width * image.scale * image.scale;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>1.对磁盘的操作，依然是放在异步串行队列里面</p>
<p>2.这里面有一个区分图片是 PNG 还是非 PNG 的判断方法，注释里已经写的很清楚</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// PNG signature bytes and data (below)</div><div class="line">static unsigned char kPNGSignatureBytes[8] = &#123;0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A&#125;;</div></pre></td></tr></table></figure>
<p>3.是为了防止 iCloud 自动备份。<code>self.shouldDisableiCloud</code> 默认为 <code>YES</code></p>
<h2 id="清理缓存通知"><a href="#清理缓存通知" class="headerlink" title="清理缓存通知"></a>清理缓存通知</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">// SDImageCache.m</div><div class="line"></div><div class="line">// Subscribe to app events</div><div class="line">// 0</div><div class="line">[[NSNotificationCenter defaultCenter] addObserver:self</div><div class="line">                                                 selector:@selector(clearMemory)</div><div class="line">                                                     name:UIApplicationDidReceiveMemoryWarningNotification</div><div class="line">                                                   object:nil];</div><div class="line"></div><div class="line">// 1</div><div class="line">[[NSNotificationCenter defaultCenter] addObserver:self</div><div class="line">                                                 selector:@selector(cleanDisk)</div><div class="line">                                                     name:UIApplicationWillTerminateNotification</div><div class="line">                                                   object:nil];</div><div class="line"></div><div class="line">// 2</div><div class="line">[[NSNotificationCenter defaultCenter] addObserver:self</div><div class="line">                                                 selector:@selector(backgroundCleanDisk)</div><div class="line">                                                     name:UIApplicationDidEnterBackgroundNotification</div><div class="line">                                                   object:nil];</div><div class="line">                                                   </div><div class="line">                                             </div><div class="line">- (void)clearMemory &#123;</div><div class="line">    [self.memCache removeAllObjects];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>0.出现内存警告时，清除内存缓存，即 <code>- (void)clearMemory</code>。</p>
<p>1.程序将要终止时，清除磁盘里过期的文件。过期时间默认为 7 天</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">static const NSInteger kDefaultCacheMaxCacheAge = 60 * 60 * 24 * 7; // 1 week</div></pre></td></tr></table></figure>
<p>2.程序进入后台时，也执行 1 中的操作。</p>
<h2 id="图片名字处理"><a href="#图片名字处理" class="headerlink" title="图片名字处理"></a>图片名字处理</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">// SDImageCache.m</div><div class="line"></div><div class="line">- (NSString *)cachedFileNameForKey:(NSString *)key &#123;</div><div class="line">    const char *str = [key UTF8String];</div><div class="line">    if (str == NULL) &#123;</div><div class="line">        str = &quot;&quot;;</div><div class="line">    &#125;</div><div class="line">    // 0</div><div class="line">    unsigned char r[CC_MD5_DIGEST_LENGTH];</div><div class="line">    CC_MD5(str, (CC_LONG)strlen(str), r);</div><div class="line">    NSString *filename = [NSString stringWithFormat:@&quot;%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%@&quot;,</div><div class="line">                          r[0], r[1], r[2], r[3], r[4], r[5], r[6], r[7], r[8], r[9], r[10],</div><div class="line">                          r[11], r[12], r[13], r[14], r[15], [[key pathExtension] isEqualToString:@&quot;&quot;] ? @&quot;&quot; : [NSString stringWithFormat:@&quot;.%@&quot;, [key pathExtension]]];</div><div class="line"></div><div class="line">    return filename;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>0.key 为图片 URL 字符串。文件名为 URL 字符串的 MD5 值。</p>
<h2 id="缓存图片文件尺寸和数量"><a href="#缓存图片文件尺寸和数量" class="headerlink" title="缓存图片文件尺寸和数量"></a>缓存图片文件尺寸和数量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">// SDImageCache.m</div><div class="line"></div><div class="line">- (NSUInteger)getSize &#123;</div><div class="line">    __block NSUInteger size = 0;</div><div class="line">    dispatch_sync(self.ioQueue, ^&#123; // 0</div><div class="line">        NSDirectoryEnumerator *fileEnumerator = [_fileManager enumeratorAtPath:self.diskCachePath];</div><div class="line">        for (NSString *fileName in fileEnumerator) &#123;</div><div class="line">            NSString *filePath = [self.diskCachePath stringByAppendingPathComponent:fileName];</div><div class="line">            NSDictionary *attrs = [[NSFileManager defaultManager] attributesOfItemAtPath:filePath error:nil];</div><div class="line">            size += [attrs fileSize];</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    return size;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSUInteger)getDiskCount &#123;</div><div class="line">    __block NSUInteger count = 0;</div><div class="line">    dispatch_sync(self.ioQueue, ^&#123; // 0</div><div class="line">        NSDirectoryEnumerator *fileEnumerator = [_fileManager enumeratorAtPath:self.diskCachePath];</div><div class="line">        count = [[fileEnumerator allObjects] count];</div><div class="line">    &#125;);</div><div class="line">    return count;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>0.获取尺寸使用的是 同步串行队列</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文接 &lt;a href=&quot;/blog/2016/04/24/sdwebimage-1/&quot;&gt;SDWebImage 源码（一）&lt;/a&gt; ，本篇阅读 &lt;code&gt;SDImageCache&lt;/code&gt; 里面的源码。  &lt;/p&gt;
&lt;p&gt;它主要负责图片缓存的存取操作。  &lt;/p&gt;
&lt;
    
    </summary>
    
      <category term="iOS" scheme="http://iYiming.me/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>阅读 SDWebImage 源码（一）</title>
    <link href="http://iYiming.me/2016/04/24/2016-04-24-sdwebimage-1/"/>
    <id>http://iYiming.me/2016/04/24/2016-04-24-sdwebimage-1/</id>
    <published>2016-04-24T04:58:52.000Z</published>
    <updated>2016-08-12T16:15:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>SDWebImage 是 Objective-C 项目中最常用的异步下载并缓存图片的第三方库。GitHub 地址：</p>
<p><a href="https://github.com/rs/SDWebImage" target="_blank" rel="external">https://github.com/rs/SDWebImage</a></p>
<p>它为我们提供了简单的入口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// #import &quot;UIImageView+WebCache.h&quot;</div><div class="line"></div><div class="line">NSURL *imageURL = [NSURL URLWithString:@&quot;XXX&quot;]; // 图片地址</div><div class="line"></div><div class="line">UIImageView *imageView = [[UIImageView alloc] init];</div><div class="line">[imageView sd_setImageWithURL:imageURL]; // 下载并缓存图片</div><div class="line">[self.view addSubview:imageView];</div></pre></td></tr></table></figure>
<p>SDWebImage 下载缓存机制如下：</p>
<p><img src="/images/SDWebImage_Read/0.png" alt="Sample Flowchart Template.png"></p>
<p>先看看它明确的职责分工：</p>
<p><code>SDImageCache</code> : 负责管理缓存 内存、硬盘<br><code>SDWebImageDownloader</code> : 负责管理下载<br><code>SDWebImageManager</code> : 负责管理上面两者  </p>
<h2 id="SDWebImageManager-干了啥"><a href="#SDWebImageManager-干了啥" class="headerlink" title="SDWebImageManager 干了啥"></a>SDWebImageManager 干了啥</h2><p>上面代码中设置图片视图 URL 后，会调用下面方法：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div></pre></td><td class="code"><pre><div class="line">// SDWebImageManager.m</div><div class="line"></div><div class="line">- (id &lt;SDWebImageOperation&gt;)downloadImageWithURL:(NSURL *)url</div><div class="line">                                         options:(SDWebImageOptions)options</div><div class="line">                                        progress:(SDWebImageDownloaderProgressBlock)progressBlock</div><div class="line">                                       completed:(SDWebImageCompletionWithFinishedBlock)completedBlock &#123;</div><div class="line">    </div><div class="line">    ...</div><div class="line">    </div><div class="line">    __block SDWebImageCombinedOperation *operation = [SDWebImageCombinedOperation new];</div><div class="line">    __weak SDWebImageCombinedOperation *weakOperation = operation;</div><div class="line"></div><div class="line">    ...</div><div class="line">    </div><div class="line">    NSString *key = [self cacheKeyForURL:url];</div><div class="line">    </div><div class="line">    // 0</div><div class="line">    operation.cacheOperation = [self.imageCache queryDiskCacheForKey:key done:^(UIImage *image, SDImageCacheType cacheType) &#123;</div><div class="line">        if (operation.isCancelled) &#123;</div><div class="line">            @synchronized (self.runningOperations) &#123;</div><div class="line">                [self.runningOperations removeObject:operation];</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        if ((!image || options &amp; SDWebImageRefreshCached) &amp;&amp; (![self.delegate respondsToSelector:@selector(imageManager:shouldDownloadImageForURL:)] || [self.delegate imageManager:self shouldDownloadImageForURL:url])) &#123;</div><div class="line">           </div><div class="line">            ...</div><div class="line">            </div><div class="line">            // 1</div><div class="line">            id &lt;SDWebImageOperation&gt; subOperation = [self.imageDownloader downloadImageWithURL:url options:downloaderOptions progress:progressBlock completed:^(UIImage *downloadedImage, NSData *data, NSError *error, BOOL finished) &#123;</div><div class="line">                __strong __typeof(weakOperation) strongOperation = weakOperation;</div><div class="line">                if (!strongOperation || strongOperation.isCancelled) &#123;</div><div class="line">                    </div><div class="line">                    ...</div><div class="line">                    </div><div class="line">                &#125;</div><div class="line">                else if (error) &#123;</div><div class="line">                    </div><div class="line">                   ...</div><div class="line">                    </div><div class="line">                &#125;</div><div class="line">                else &#123;</div><div class="line">                    </div><div class="line">                    ...</div><div class="line">                    </div><div class="line">                    BOOL cacheOnDisk = !(options &amp; SDWebImageCacheMemoryOnly);</div><div class="line">                    </div><div class="line">                    if (options &amp; SDWebImageRefreshCached &amp;&amp; image &amp;&amp; !downloadedImage) &#123;</div><div class="line">                        </div><div class="line">                    &#125; else if (downloadedImage &amp;&amp; (!downloadedImage.images || (options &amp; SDWebImageTransformAnimatedImage)) &amp;&amp; [self.delegate respondsToSelector:@selector(imageManager:transformDownloadedImage:withURL:)]) &#123; // 2</div><div class="line">                        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123;</div><div class="line">                            UIImage *transformedImage = [self.delegate imageManager:self transformDownloadedImage:downloadedImage withURL:url];</div><div class="line">                            </div><div class="line">                            if (transformedImage &amp;&amp; finished) &#123;</div><div class="line">                                BOOL imageWasTransformed = ![transformedImage isEqual:downloadedImage];</div><div class="line">                                [self.imageCache storeImage:transformedImage recalculateFromImage:imageWasTransformed imageData:(imageWasTransformed ? nil : data) forKey:key toDisk:cacheOnDisk];</div><div class="line">                            &#125;</div><div class="line">                            </div><div class="line">                            dispatch_main_sync_safe(^&#123;</div><div class="line">                                if (strongOperation &amp;&amp; !strongOperation.isCancelled) &#123;</div><div class="line">                                    completedBlock(transformedImage, nil, SDImageCacheTypeNone, finished, url);</div><div class="line">                                &#125;</div><div class="line">                            &#125;);</div><div class="line">                        &#125;);</div><div class="line">                    &#125; else &#123; // 2</div><div class="line">                        if (downloadedImage &amp;&amp; finished) &#123;</div><div class="line">                            [self.imageCache storeImage:downloadedImage recalculateFromImage:NO imageData:data forKey:key toDisk:cacheOnDisk];</div><div class="line">                        &#125;</div><div class="line">                        </div><div class="line">                        dispatch_main_sync_safe(^&#123;</div><div class="line">                            if (strongOperation &amp;&amp; !strongOperation.isCancelled) &#123;</div><div class="line">                                completedBlock(downloadedImage, nil, SDImageCacheTypeNone, finished, url);</div><div class="line">                            &#125;</div><div class="line">                        &#125;);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                </div><div class="line">                ...</div><div class="line">            &#125;];</div><div class="line">         </div><div class="line">            ...</div><div class="line">        &#125;</div><div class="line">        else if (image) &#123; // 3</div><div class="line">            dispatch_main_sync_safe(^&#123;</div><div class="line">                __strong __typeof(weakOperation) strongOperation = weakOperation;</div><div class="line">                if (strongOperation &amp;&amp; !strongOperation.isCancelled) &#123;</div><div class="line">                    completedBlock(image, nil, cacheType, YES, url);</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">            </div><div class="line">            ...</div><div class="line">        &#125;</div><div class="line">        else &#123;</div><div class="line">           ...</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line">    </div><div class="line">    return operation;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>0.查询本地（内存、磁盘）缓存  </p>
<p>1.本地没有缓存，从网络上下载</p>
<p>2.下载完成后，缓存到本地（内存、磁盘）并返回</p>
<p>3.如果本地存在缓存（内存中有直接取出，磁盘中有存到内存中再取出） 直接取出 并返回</p>
<h2 id="是否有缓存-内存、磁盘-？"><a href="#是否有缓存-内存、磁盘-？" class="headerlink" title="是否有缓存(内存、磁盘)？"></a>是否有缓存(内存、磁盘)？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">// SDImageCache.m</div><div class="line"></div><div class="line">- (NSOperation *)queryDiskCacheForKey:(NSString *)key done:(SDWebImageQueryCompletedBlock)doneBlock &#123; // 0</div><div class="line">    if (!doneBlock) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (!key) &#123;</div><div class="line">        doneBlock(nil, SDImageCacheTypeNone);</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // First check the in-memory cache...</div><div class="line">    UIImage *image = [self imageFromMemoryCacheForKey:key]; // 1</div><div class="line">    if (image) &#123;</div><div class="line">        doneBlock(image, SDImageCacheTypeMemory);</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    NSOperation *operation = [NSOperation new]; // 2 </div><div class="line">    dispatch_async(self.ioQueue, ^&#123; // 3</div><div class="line">        if (operation.isCancelled) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @autoreleasepool &#123; // 4</div><div class="line">            UIImage *diskImage = [self diskImageForKey:key]; // 5</div><div class="line">            if (diskImage &amp;&amp; self.shouldCacheImagesInMemory) &#123;</div><div class="line">                NSUInteger cost = SDCacheCostForImage(diskImage);</div><div class="line">                [self.memCache setObject:diskImage forKey:key cost:cost]; // 6</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">                doneBlock(diskImage, SDImageCacheTypeDisk);</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    return operation;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>0.key 为 图片 URL 字符串 </p>
<p>1.去根据 key 查找内存中是否存在缓存的图片  </p>
<p>2.创建 IO Operation 最后方法会返回</p>
<p>3.异步串行队列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">_ioQueue = dispatch_queue_create(&quot;com.hackemist.SDWebImageCache&quot;, DISPATCH_QUEUE_SERIAL);</div></pre></td></tr></table></figure>
<p>4.创建自动释放池，使内存及时释放</p>
<p>5.从硬盘里取出图片  </p>
<p>6.缓存到内存</p>
<h2 id="没有缓存那就下载"><a href="#没有缓存那就下载" class="headerlink" title="没有缓存那就下载"></a>没有缓存那就下载</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div></pre></td><td class="code"><pre><div class="line">// SDWebImageDownloader.m</div><div class="line"></div><div class="line">- (id &lt;SDWebImageOperation&gt;)downloadImageWithURL:(NSURL *)url options:(SDWebImageDownloaderOptions)options progress:(SDWebImageDownloaderProgressBlock)progressBlock completed:(SDWebImageDownloaderCompletedBlock)completedBlock &#123;</div><div class="line">    __block SDWebImageDownloaderOperation *operation;</div><div class="line">    __weak __typeof(self)wself = self;</div><div class="line"></div><div class="line">    [self addProgressCallback:progressBlock completedBlock:completedBlock forURL:url createCallback:^&#123;</div><div class="line">        NSTimeInterval timeoutInterval = wself.downloadTimeout;</div><div class="line">        if (timeoutInterval == 0.0) &#123;</div><div class="line">            timeoutInterval = 15.0; // 0</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 1</div><div class="line">        // In order to prevent from potential duplicate caching (NSURLCache + SDImageCache) we disable the cache for image requests if told otherwise</div><div class="line">        NSMutableURLRequest *request = [[NSMutableURLRequest alloc] initWithURL:url cachePolicy:(options &amp; SDWebImageDownloaderUseNSURLCache ? NSURLRequestUseProtocolCachePolicy : NSURLRequestReloadIgnoringLocalCacheData) timeoutInterval:timeoutInterval]; </div><div class="line">        request.HTTPShouldHandleCookies = (options &amp; SDWebImageDownloaderHandleCookies);</div><div class="line">        request.HTTPShouldUsePipelining = YES;</div><div class="line">        if (wself.headersFilter) &#123;</div><div class="line">            request.allHTTPHeaderFields = wself.headersFilter(url, [wself.HTTPHeaders copy]);</div><div class="line">        &#125;</div><div class="line">        else &#123;</div><div class="line">            request.allHTTPHeaderFields = wself.HTTPHeaders;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        // 2</div><div class="line">        operation = [[wself.operationClass alloc] initWithRequest:request</div><div class="line">                                                          options:options</div><div class="line">                                                         progress:^(NSInteger receivedSize, NSInteger expectedSize) &#123; // 3</div><div class="line">                                                             SDWebImageDownloader *sself = wself;</div><div class="line">                                                             if (!sself) return;</div><div class="line">                                                             __block NSArray *callbacksForURL;</div><div class="line">                                                             dispatch_sync(sself.barrierQueue, ^&#123;</div><div class="line">                                                                 callbacksForURL = [sself.URLCallbacks[url] copy];</div><div class="line">                                                             &#125;);</div><div class="line">                                                             for (NSDictionary *callbacks in callbacksForURL) &#123;</div><div class="line">                                                                 dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">                                                                     SDWebImageDownloaderProgressBlock callback = callbacks[kProgressCallbackKey];</div><div class="line">                                                                     if (callback) callback(receivedSize, expectedSize);</div><div class="line">                                                                 &#125;);</div><div class="line">                                                             &#125;</div><div class="line">                                                         &#125;</div><div class="line">                                                        completed:^(UIImage *image, NSData *data, NSError *error, BOOL finished) &#123; // 4</div><div class="line">                                                            SDWebImageDownloader *sself = wself;</div><div class="line">                                                            if (!sself) return;</div><div class="line">                                                            __block NSArray *callbacksForURL;</div><div class="line">                                                            dispatch_barrier_sync(sself.barrierQueue, ^&#123;</div><div class="line">                                                                callbacksForURL = [sself.URLCallbacks[url] copy];</div><div class="line">                                                                if (finished) &#123;</div><div class="line">                                                                    [sself.URLCallbacks removeObjectForKey:url];</div><div class="line">                                                                &#125;</div><div class="line">                                                            &#125;);</div><div class="line">                                                            for (NSDictionary *callbacks in callbacksForURL) &#123;</div><div class="line">                                                                SDWebImageDownloaderCompletedBlock callback = callbacks[kCompletedCallbackKey];</div><div class="line">                                                                if (callback) callback(image, data, error, finished);</div><div class="line">                                                            &#125;</div><div class="line">                                                        &#125;</div><div class="line">                                                        cancelled:^&#123;</div><div class="line">                                                            SDWebImageDownloader *sself = wself;</div><div class="line">                                                            if (!sself) return;</div><div class="line">                                                            dispatch_barrier_async(sself.barrierQueue, ^&#123;</div><div class="line">                                                                [sself.URLCallbacks removeObjectForKey:url];</div><div class="line">                                                            &#125;);</div><div class="line">                                                        &#125;];</div><div class="line">        operation.shouldDecompressImages = wself.shouldDecompressImages;</div><div class="line">        </div><div class="line">        if (wself.urlCredential) &#123;</div><div class="line">            operation.credential = wself.urlCredential;</div><div class="line">        &#125; else if (wself.username &amp;&amp; wself.password) &#123;</div><div class="line">            operation.credential = [NSURLCredential credentialWithUser:wself.username password:wself.password persistence:NSURLCredentialPersistenceForSession];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        // 4</div><div class="line">        if (options &amp; SDWebImageDownloaderHighPriority) &#123;</div><div class="line">            operation.queuePriority = NSOperationQueuePriorityHigh;</div><div class="line">        &#125; else if (options &amp; SDWebImageDownloaderLowPriority) &#123;</div><div class="line">            operation.queuePriority = NSOperationQueuePriorityLow;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        [wself.downloadQueue addOperation:operation]; // 5</div><div class="line">        if (wself.executionOrder == SDWebImageDownloaderLIFOExecutionOrder) &#123;</div><div class="line">            // Emulate LIFO execution order by systematically adding new operations as last operation&apos;s dependency</div><div class="line">            [wself.lastAddedOperation addDependency:operation];</div><div class="line">            wself.lastAddedOperation = operation;</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">    return operation;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>0.下载超时时间设置。默认：15 秒  </p>
<p>1.<code>NSMutableURLRequest</code> 设置。即请求设置</p>
<p>2.下载 <code>Operation</code>。即 <code>SDWebImageDownloaderOperation</code> ，它继承自 NSOperation 的并发操作。</p>
<p>3.下载进度  </p>
<p>4.操作优先级  </p>
<p>5.将下载操作添加至下载队列  </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SDWebImage 是 Objective-C 项目中最常用的异步下载并缓存图片的第三方库。GitHub 地址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/rs/SDWebImage&quot; target=&quot;_blank&quot; rel=&quot;external
    
    </summary>
    
      <category term="iOS" scheme="http://iYiming.me/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS 状态栏样式</title>
    <link href="http://iYiming.me/2016/04/10/2016-04-10-she-zhi-ios-zhuang-tai-lan-yang-shi/"/>
    <id>http://iYiming.me/2016/04/10/2016-04-10-she-zhi-ios-zhuang-tai-lan-yang-shi/</id>
    <published>2016-04-10T04:07:30.000Z</published>
    <updated>2016-08-12T16:16:10.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/she-zhi-ios-zhuang-tai-lan/0.jpg" alt="/images/she-zhi-ios-zhuang-tai-lan/0.jpg">  </p>
<p>一直也没有使用新 API 来设置状态栏，在使用的过程中，遇到了问题，整理下：</p>
<p>关于状态栏设置,原先一直使用系统提供的如下方法： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[[UIApplication sharedApplication] setStatusBarStyle:UIStatusBarStyleLightContent];</div><div class="line"></div><div class="line">// 加动画</div><div class="line">[[UIApplication sharedApplication] setStatusBarStyle:UIStatusBarStyleLightContent animated:YES];</div></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[[UIApplication sharedApplication] setStatusBarStyle:UIStatusBarStyleDefault];</div><div class="line"></div><div class="line">// 加动画</div><div class="line">[[UIApplication sharedApplication] setStatusBarStyle:UIStatusBarStyleDefault animated:YES];</div></pre></td></tr></table></figure>
<p><strong>注意：使用这个方法，还需要设置项目 Info.plist 文件中的 <code>UIViewControllerBasedStatusBarAppearance</code> 为 <code>NO</code>。</strong></p>
<p>遗憾的是，这个 API 在 iOS 9 已经被废弃了。</p>
<p>早在 iOS 7 就出现了新的设置状态栏的 API:</p>
<p>在 <code>UIViewController</code> 添加了 <code>- (UIStatusBarStyle)preferredStatusBarStyle;</code></p>
<h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><p>新建一个 Demo, 其中 <code>ZYQRootViewController</code> 是一个 <code>UIViewController</code> 的子类，代码如下：</p>
<p><code>AppDelegate.m</code> 代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;</div><div class="line">    self.window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds];</div><div class="line">    </div><div class="line">    ZYQRootViewController *rootViewController = [[ZYQRootViewController alloc] init];</div><div class="line">    self.window.rootViewController = rootViewController;</div><div class="line">    [self.window makeKeyAndVisible];</div><div class="line">    </div><div class="line">    return YES;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 <code>ZYQRootViewController</code> 实现 <code>- (UIStatusBarStyle)preferredStatusBarStyle;</code> 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (UIStatusBarStyle)preferredStatusBarStyle &#123;</div><div class="line">    return UIStatusBarStyleLightContent;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行发现没问题，设置成功！</p>
<h3 id="在-UINavigationController-中使用出现的问题"><a href="#在-UINavigationController-中使用出现的问题" class="headerlink" title="在 UINavigationController 中使用出现的问题"></a>在 UINavigationController 中使用出现的问题</h3><p>如果把 <code>AppDelegate.m</code> 代码改为：</p>
<p> <code>ZYQRootViewController</code> 包一个 <code>UINavigationController</code>,将 <code>window.rootViewController</code> 设置为 <code>UINavigationController</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;</div><div class="line">    self.window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds];</div><div class="line">    </div><div class="line">    ZYQRootViewController *rootViewController = [[ZYQRootViewController alloc] init];</div><div class="line">    UINavigationController *navController = [[UINavigationController alloc] initWithRootViewController:rootViewController];</div><div class="line">    self.window.rootViewController = navController;</div><div class="line">    [self.window makeKeyAndVisible];</div><div class="line">    </div><div class="line">    return YES;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行发现,在 <code>ZYQRootViewController</code> 实现 <code>- (UIStatusBarStyle)preferredStatusBarStyle;</code> 方法没有调用。Why？</p>
<p><strong>因为 <code>UINavigationController</code> 将自己处理如何设置状态栏，而不是传递给它的子控制器。</strong></p>
<p>如何解决这个问题？</p>
<p>在 UIViewController 类别里找到下面方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// Override to return a child view controller or nil. If non-nil, that view controller&apos;s status bar appearance attributes will be used. If nil, self is used. Whenever the return values from these methods change, -setNeedsUpdatedStatusBarAttributes should be called.</div><div class="line">- (nullable UIViewController *)childViewControllerForStatusBarStyle NS_AVAILABLE_IOS(7_0) __TVOS_PROHIBITED;</div></pre></td></tr></table></figure>
<p>如果重写了这个方法，返回我们想使用的控制器来控制状态栏样式。我们可以为 <code>UINavigationController</code> 添加类别，来重写这个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">#import &quot;UINavigationController+ZYQStatusBarStyle.h&quot;</div><div class="line"></div><div class="line">@implementation UINavigationController (ZYQStatusBarStyle)</div><div class="line"></div><div class="line">- (UIViewController *)childViewControllerForStatusBarStyle &#123;</div><div class="line">    return self.topViewController; // 返回最顶部的控制器</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>添加 <code>UINavigationController (ZYQStatusBarStyle)</code> 类别后，我们就可以正常调用 <code>ZYQRootViewController</code> 实现 <code>- (UIStatusBarStyle)preferredStatusBarStyle;</code> 的方法了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/she-zhi-ios-zhuang-tai-lan/0.jpg&quot; alt=&quot;/images/she-zhi-ios-zhuang-tai-lan/0.jpg&quot;&gt;  &lt;/p&gt;
&lt;p&gt;一直也没有使用新 API 来设置状态栏，在使用的过程中，
    
    </summary>
    
      <category term="iOS" scheme="http://iYiming.me/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>如何做一个自我要求的读者</title>
    <link href="http://iYiming.me/2016/03/30/2016-03-30-ru-he-zuo-yi-ge-zi-wo-yao-qiu-de-du-zhe/"/>
    <id>http://iYiming.me/2016/03/30/2016-03-30-ru-he-zuo-yi-ge-zi-wo-yao-qiu-de-du-zhe/</id>
    <published>2016-03-29T23:46:58.000Z</published>
    <updated>2016-08-12T16:16:48.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/how-to-read-a-book-1/0.jpg" alt="0.jpg"></p>
<p>最近正在读《如何阅读一本书》，阅读的过程中，发现了好多以前不知道或者是搞错的东西。现在整理下来，算是这本书的第一篇阅读笔记吧。</p>
<p>如题，如何做一个自我要求的读者？这个问题可以扩大到任何地方，如何做一个自我要求的程序猿？如何做一个自我要求的产品经理？如何做一个自我要求的人？原先的多少次读书，纯粹是为了以后的谈资，骄傲的说自己读过，而没有完全思考，或者说是没有去主动阅读。</p>
<p>摘抄书里的一段话，共勉：</p>
<blockquote>
<p>拿同样的书给不同的人阅读，一个人却读的比另一个人好这件事，首先在于这人的阅读更主动，其次，在于他在阅读中的每一种活动都参与了更多的技巧。</p>
</blockquote>
<h1 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h1><h3 id="阅读的意义"><a href="#阅读的意义" class="headerlink" title="阅读的意义"></a>阅读的意义</h3><blockquote>
<p>我们可以将“阅读”这个词，区分成两种不同的意义</p>
<p>第一种意义是我们在阅读报纸、杂志，或者其他的东西时，凭我们的阅读技巧与聪明才智，一下子便能融会贯通了。</p>
<p>第二种意义是一个人试着读某样他一开始并不怎么了解的东西。这个东西的水平就是比阅读的人高一截。这个作者想要表达的东西，能增进读者的理解力。</p>
</blockquote>
<p>《如何阅读一本书》是增进我们理解力的一本书。我们平常看新闻，刷微博，结论大张旗鼓的给我列出了，替代了我们的思考，让主动思考这件事情变得没那么重要。但我们还得去主动思考，正是这本书要教的。</p>
<h3 id="学会去提问题，并尽可能找出答案"><a href="#学会去提问题，并尽可能找出答案" class="headerlink" title="学会去提问题，并尽可能找出答案"></a>学会去提问题，并尽可能找出答案</h3><blockquote>
<p>一个阅读者要提出的四个基本问题</p>
<ul>
<li>整体来说，这本书到底在谈些什么？</li>
<li>作者细部说了什么，怎么说的？</li>
<li>这本书说的有道理吗？是全部有道理，还是部分有道理？</li>
<li>这本书跟你有什么关系？</li>
</ul>
<p>任何一种超越基础阅读的阅读层次，核心就在你要努力提出问题（然后尽你可能地找出答案）。这是绝对不可或忘得原则。这也是自我要求的阅读者，与没有自我要求的阅读者之间，有天壤之别的原因。后者提不出问题——当然也得不到答案。</p>
<p>光知道这四个问题还不够。在阅读过程中，你要记得去提出这些问题。要养成这样的习惯，才能成为一个有自我要求的阅读者。</p>
</blockquote>
<p>现在想想，原先读过的书，有多少是混过来的，眼睛里看过过一下脑子，转眼就忘了。没有问问题的习惯，即使有问题，也不会去尽力去找答案。学会提出问题，才会让一本书真正属于你自己。</p>
<h3 id="边读边写，在书上做笔记"><a href="#边读边写，在书上做笔记" class="headerlink" title="边读边写，在书上做笔记"></a>边读边写，在书上做笔记</h3><blockquote>
<p>你买了一本书，就像是买了一项资产，和你付钱买衣服或家具是一样的。要让书成为你的一部分，就是去写下来。</p>
<p>为什么对阅读来说，在书上做笔记是不可获取的事？  </p>
<p>第一，那会让你保持清醒。<br>第二，阅读，如果是主动的，就是一种思考，而思考倾向于用语言表达出来。<br>第三，将你的感想写下来，能帮助你记住作者的思想。  </p>
</blockquote>
<p>原先曾经写过一篇文章，主要是说自己读完一本书，干干净净，毫无收获，看起来和新的一样。现在在这里找到了答案。现在边读边写在书上，就像第二点说的思考倾向于用语言表达出来，也就是再说要输出出来，不管是讲的还是写的。</p>
<h3 id="如何去做笔记"><a href="#如何去做笔记" class="headerlink" title="如何去做笔记"></a>如何去做笔记</h3><blockquote>
<p>1.画底线——在主要的重点，或重要又有力量的句子下画线。   </p>
<p>2.在画底线出的栏外再加画一道线——把你已经画线的部分再强调一遍，或是某一段很重要，但要画底线太长了，便在这一整段外加上一个记号。  </p>
<p>3.在空白处做星号或其他符号  </p>
<p>4.在空白处编号——作者某个论点发展出一连串的重要陈述时，可以做顺序编号。</p>
<p>5.在空白处记下其他的页码  </p>
<p>6.将关键字或者句子圈出来  </p>
<p>7.在书页的空白处做笔记  </p>
</blockquote>
<p>做笔记的形式可能因人而异。第一点、第六点、第七点比较常见。有时看技术书是第五点也比较常用。第四点不是很理解作者个意思，难道就是标出1，2，3，4？第二点和第三点也可以在以后的阅读中使用。  </p>
<h3 id="如何有系统的略读或粗读"><a href="#如何有系统的略读或粗读" class="headerlink" title="如何有系统的略读或粗读"></a>如何有系统的略读或粗读</h3><blockquote>
<p>场景一:遇到一本书,你并不知道自己想不想读。</p>
<p>场景二：遇到一本书，你想要发掘所有的东西，但时间有限。</p>
</blockquote>
<p>遇到上面的问题，检视阅读就会给我们答案。书里面是给的这么一些建议：</p>
<blockquote>
<p>1.先看书名页，然后如果有序就先看序。</p>
<p>2.研究目录页。</p>
<p>3.如果书中附有索引，也要检阅一下。</p>
<p>4.如果那是本包着书衣的新书，不妨读一下出版者的介绍。</p>
<p>5.从你对一本书的目录很概略，甚至有点模糊的印象当中，开始挑几个看来跟主题息息相关的篇章来看。</p>
<p>6.最后一步，把书打开来，东翻翻西翻翻，念一两段，有时候连续读几页，但不要太多。</p>
</blockquote>
<p>其实电子书和纸质书可能完全不一样，我会先去看看书的整体介绍，在去看看目录页，然后读一下前面的序言或者是推荐语。这个自己原先做的可能相对于其他来说要做的好些。</p>
<h1 id="误区"><a href="#误区" class="headerlink" title="误区"></a>误区</h1><h3 id="读书是为了催眠"><a href="#读书是为了催眠" class="headerlink" title="读书是为了催眠"></a>读书是为了催眠</h3><blockquote>
<p>如果你的阅读目标是获得利益——不论是心灵或精神上的成长——你就得保持清醒。</p>
</blockquote>
<p>我前些天写日记，说为了让自己晚上保持不那么兴奋，决定去睡前读书。其实这是有过多次切身感受（曾经好几次读完书，读着读着就睡着了）得出的结论，但是读这本书，发现这个结论是错误的。要想晚上保持不兴奋，喝牛奶才是王道。</p>
<h3 id="想和做-其实就是理想和现实的距离"><a href="#想和做-其实就是理想和现实的距离" class="headerlink" title="想和做 其实就是理想和现实的距离"></a>想和做 其实就是理想和现实的距离</h3><blockquote>
<p>如何养成阅读习惯，除了不断地运作练习之外，别无他法。</p>
</blockquote>
<p>要养成阅读习惯，好像也不是一天两天的事情。就和一开始学习盲打一样（关灯写日记，不断练习），现在学会了，感觉很是方便。现在阅读的时间主要是看电子书（相比较于实体书，可能不好记录自己的想法，有时候想法一闪而过，没有记录下来。但是方便的一点是我可以现买现看，存储笔记不丢失)。还是没有学会一开始去检视阅读，去按照书里介绍的步骤走一走，想必每次看本新书都按照这个步骤走，时间长了一定会养成习惯的。  </p>
<h3 id="如何面对一本难读的书"><a href="#如何面对一本难读的书" class="headerlink" title="如何面对一本难读的书"></a>如何面对一本难读的书</h3><blockquote>
<p>头一次面对一本难读的书的时候，从头到尾先读完一遍，碰到不懂得地方不要停下来查询或思索。</p>
<p>你从头到尾读了一遍之后的了解——就算只有 50% 或更少——能帮助你在后来重读一次略过的部分时，增进理解，就算你不重读，对一本难度很高的书了解了一半，也比什么都不了解来得好些——如果你让自己在一碰上困难的地方停住，最后就可能对这本书真的一无所知。</p>
</blockquote>
<p>这是我读本书以来，收获最大的地方。原先遇到读不懂的地方就停了下来去找去查。自我感觉，应该这样去处理，遇到不懂的地方先记录下来，不要耽误下面的阅读。私下时间可以去查找相关的问题，当再次阅读时，收获的可能会更多！</p>
<p>生命中遇见的每一本书都不是偶然。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/how-to-read-a-book-1/0.jpg&quot; alt=&quot;0.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;最近正在读《如何阅读一本书》，阅读的过程中，发现了好多以前不知道或者是搞错的东西。现在整理下来，算是这本书的第一篇阅读笔记吧。&lt;/p&gt;
&lt;p&gt;
    
    </summary>
    
      <category term="破万卷" scheme="http://iYiming.me/categories/%E7%A0%B4%E4%B8%87%E5%8D%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>Objective-C 代码规范</title>
    <link href="http://iYiming.me/2016/03/29/2016-03-29-objective-c-dai-ma-gui-fan/"/>
    <id>http://iYiming.me/2016/03/29/2016-03-29-objective-c-dai-ma-gui-fan/</id>
    <published>2016-03-29T12:19:21.000Z</published>
    <updated>2016-08-14T00:59:38.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/objective-c-dai-ma-gui-fan/01.jpg" alt="objective-c-dai-ma-gui-fan"></p>
<p><a href="https://github.com/NYTimes/objective-c-style-guide" target="_blank" rel="external">纽约时报 Objective-C Style Guide</a>  </p>
<p><a href="http://zh-google-styleguide.readthedocs.org/en/latest/google-objc-styleguide/" target="_blank" rel="external">Google Objective-C Style Guide</a>  </p>
<p>上面是前些天看的关于 Objective-C 代码规范的文章，发现了一些原先代码书写不规范的地方，现整理如下：</p>
<p>0.属性推荐使用点语法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">view.backgroundColor = [UIColor orangeColor];</div><div class="line">[UIApplication sharedApplication].delegate;</div></pre></td></tr></table></figure>
<p>而不是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[view setBackgroundColor:[UIColor orangeColor]];</div><div class="line">UIApplication.sharedApplication.delegate;</div></pre></td></tr></table></figure>
<p>1.if else 的 写法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">if (window) &#123;</div><div class="line">  [self windowDidLoad:window];</div><div class="line">&#125; else &#123;</div><div class="line">  [self errorLoadingWindow];</div><div class="line">&#125;</div><div class="line"></div><div class="line">if (window) &#123;</div><div class="line">  [self windowDidLoad:window];</div><div class="line">&#125; else if (self)&#123;</div><div class="line">  [self errorLoadingWindow];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>2.Error 判断</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NSError *error;</div><div class="line">if (![self trySomethingWithError:&amp;error]) &#123;</div><div class="line">    // Handle Error</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而不是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">NSError *error;</div><div class="line">[self trySomethingWithError:&amp;error];</div><div class="line">if (error) &#123;</div><div class="line">    // Handle Error</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>3.方法的书写</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (void)setExampleText:(NSString *)text image:(UIImage *)image;</div><div class="line"></div><div class="line">- (void)setExampleText:(NSString *)text image:(UIImage *)image &#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>4.类别命名应该准确，体现其功能</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@interface UIViewController (NYTMediaPlaying)</div><div class="line">@interface NSString (NSStringEncodingDetection)</div></pre></td></tr></table></figure>
<p>而不是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@interface NYTAdvertisement (private)</div><div class="line">@interface NSString (NYTAdditions)</div></pre></td></tr></table></figure>
<p>5.添加到类别的方法或者属性 必须要加上前缀</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@interface NSArray (NYTAccessors)</div><div class="line">- (id)nyt_objectOrNilAtIndex:(NSUInteger)index;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>而不是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@interface NSArray (NYTAccessors)</div><div class="line">- (id)objectOrNilAtIndex:(NSUInteger)index;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>6.注释使用 VVDocumenter 就 OK 了</p>
<p>7.<code>CGRect</code> 函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">CGRect frame = self.view.frame;</div><div class="line"></div><div class="line">CGFloat x = CGRectGetMinX(frame);</div><div class="line">CGFloat y = CGRectGetMinY(frame);</div><div class="line">CGFloat width = CGRectGetWidth(frame);</div><div class="line">CGFloat height = CGRectGetHeight(frame);</div></pre></td></tr></table></figure>
<p>而不是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">CGRect frame = self.view.frame;</div><div class="line"></div><div class="line">CGFloat x = frame.origin.x;</div><div class="line">CGFloat y = frame.origin.y;</div><div class="line">CGFloat width = frame.size.width;</div><div class="line">CGFloat height = frame.size.height;</div></pre></td></tr></table></figure>
<p>8.常量声明</p>
<p>使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">static NSString * const NYTAboutViewControllerCompanyName = @&quot;The New York Times Company&quot;;</div><div class="line"></div><div class="line">static const CGFloat NYTImageThumbnailHeight = 50.0;</div></pre></td></tr></table></figure>
<p>而不是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#define CompanyName @&quot;The New York Times Company&quot;</div><div class="line"></div><div class="line">#define thumbnailHeight 2</div></pre></td></tr></table></figure>
<p>9.如果有多个引入 要去分组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// Frameworks</div><div class="line">@import QuartzCore;</div><div class="line"></div><div class="line">// Models</div><div class="line">#import &quot;NYTUser.h&quot;</div><div class="line"></div><div class="line">// Views</div><div class="line">#import &quot;NYTButton.h&quot;</div><div class="line">#import &quot;NYTUserView.h&quot;</div></pre></td></tr></table></figure>
<p>10.在协议或者数据源中，第一个参数应当是发送消息的对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath;</div></pre></td></tr></table></figure>
<p>而不是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)didSelectTableRowAtIndexPath:(NSIndexPath *)indexPath;</div></pre></td></tr></table></figure>
<p>11.<code>@public</code> 和 <code>@private</code> 访问修饰符应该以一个空格缩进</p>
<p>12.异常：每个 <code>@</code> 标签应该有独立的一行，在 <code>@</code> 与 <code>{}</code> 之间需要有一个空格，<code>@catch</code> 与被捕捉到的异常对象的声明之间也要有一个空格。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@try &#123;</div><div class="line">  foo();</div><div class="line">&#125;</div><div class="line">@catch (NSException *ex) &#123;</div><div class="line">  bar(ex);</div><div class="line">&#125;</div><div class="line">@finally &#123;</div><div class="line">  baz();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>13.Treat Warnings as Errors</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/objective-c-dai-ma-gui-fan/01.jpg&quot; alt=&quot;objective-c-dai-ma-gui-fan&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/NYTimes/objecti
    
    </summary>
    
      <category term="iOS" scheme="http://iYiming.me/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>一个粘性动画的源码分析</title>
    <link href="http://iYiming.me/2016/03/27/2016-03-27-yi-ge-nian-xing-dong-hua-de-yuan-ma-fen-xi/"/>
    <id>http://iYiming.me/2016/03/27/2016-03-27-yi-ge-nian-xing-dong-hua-de-yuan-ma-fen-xi/</id>
    <published>2016-03-27T02:54:09.000Z</published>
    <updated>2016-08-14T01:00:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>周四(2016-03-24)下午在公司做了一次技术分享，现整理成博客的形式。  </p>
<p>分享的内容是一款动画，动画源码下载地址、效果及 Keynote 下载地址如下：</p>
<p>源码下载地址：  </p>
<p><a href="https://github.com/KittenYang/GooeyTabbar" target="_blank" rel="external">https://github.com/KittenYang/GooeyTabbar</a> </p>
<p>Keynote 下载地址：</p>
<p><a href="http://pan.baidu.com/s/1qYUUKaw" target="_blank" rel="external">http://pan.baidu.com/s/1qYUUKaw</a>  </p>
<p>源码效果：  </p>
<p><img src="/images/animation_gooeytabbar/01.gif" alt="animation_gooeytabbar/01.gif">    </p>
<h2 id="0-什么是-CADisplayLink-？"><a href="#0-什么是-CADisplayLink-？" class="headerlink" title="0.什么是 CADisplayLink ？"></a>0.什么是 CADisplayLink ？</h2><h4 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h4><blockquote>
<p>A CADisplayLink object is a timer object that allows your application to synchronize its drawing to the refresh rate of the display.  </p>
<p>——By Apple</p>
<p>CADisplayLink 对象是一个定时器对象，能够让你的应用程序随着屏幕刷新频率同步绘制。</p>
</blockquote>
<h4 id="如何使用-CADisplayLink-？"><a href="#如何使用-CADisplayLink-？" class="headerlink" title="如何使用 CADisplayLink ？"></a>如何使用 CADisplayLink ？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">var displayLink: CADisplayLink? // 声明一个 CADisplayLink 对象</div><div class="line"></div><div class="line">/**</div><div class="line">配置 CADisplayLink 对象</div><div class="line">*/</div><div class="line">func configDisplayLink() &#123;</div><div class="line">  displayLink = CADisplayLink(target: self, selector: &quot;handleDisplayLink:&quot;)</div><div class="line">  displayLink?.addToRunLoop(NSRunLoop.currentRunLoop(), forMode: NSDefaultRunLoopMode)</div><div class="line">&#125;</div><div class="line">    </div><div class="line">/**</div><div class="line">执行 CADisplayLink 指定的方法</div><div class="line">    </div><div class="line">- parameter displayLink: 即上面初始化的 displayLink</div><div class="line">*/</div><div class="line">func handleDisplayLink(displayLink: CADisplayLink)&#123;</div><div class="line">    //这里做些处理事情</div><div class="line"></div><div class="line">&#125;</div><div class="line">    </div><div class="line">/**</div><div class="line">  关闭 DisplayLink</div><div class="line">*/</div><div class="line">func stopDisplayLink()&#123;</div><div class="line">    displayLink?.invalidate() //从 Runloop 中移除</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>用代码的方式解释一下: </p>
<ol>
<li><p><code>CADisplayLink</code> 对象指定了一个选择器 <code>handleDisplayLink:</code>。  </p>
</li>
<li><p>将 <code>CADisplayLink</code> 对象添加至 <code>NSRunLoop.currentRunLoop()</code> 。</p>
</li>
<li><p>屏幕刷新完毕后，会执行上面指定的选择器 <code>handleDisplayLink:</code>（iOS 设备的屏幕刷新频率( FPS )是 60Hz，因此 <code>CADisplayLink</code> 的 <code>selector</code> 默认调用周期是每秒 60 次）。</p>
</li>
</ol>
<h4 id="CADisplayLink-VS-NSTimer"><a href="#CADisplayLink-VS-NSTimer" class="headerlink" title="CADisplayLink VS NSTimer"></a>CADisplayLink VS NSTimer</h4><p>看完上面的介绍，肯定会问 <code>CADisplayLink</code> 和 <code>NSTimer</code> 有什么区别？</p>
<p>1、原理不同  </p>
<blockquote>
<p><code>CADisplayLink</code> 是一个能让我们以和屏幕刷新率同步的频率将特定的内容画到屏幕上的定时器类。<code>CADisplayLink</code> 以特定模式注册到 Runloop 后，每当屏幕显示内容刷新结束的时候，Runloop 就会向 <code>CADisplayLink</code> 指定的 target 发送一次指定的 selector 消息， <code>CADisplayLink</code> 类对应的 selector 就会被调用一次。<br><code>NSTimer</code> 以指定的模式注册到 Runloop 后，每当设定的周期时间到达后，Runloop会向指定的 target 发送一次指定的 selector 消息。</p>
</blockquote>
<p>2、周期设置方式不同  </p>
<blockquote>
<p>iOS设备的屏幕刷新频率(FPS)是60Hz，因此 <code>CADisplayLink</code> 的 selector 默认调用周期是每秒 60 次，这个周期可以通过 <code>frameInterval</code> 属性设置，<code>CADisplayLink</code> 的 selector 每秒调用次数 <code>=60/frameInterval</code>。比如当 <code>frameInterval</code> 设为 2，每秒调用就变成 30 次。因此，<code>CADisplayLink</code> 周期的设置方式略显不便。  </p>
<p><code>NSTimer</code> 的 selector 调用周期可以在初始化时直接设定，相对就灵活的多。</p>
</blockquote>
<p>3、精确度不同  </p>
<blockquote>
<p>iOS 设备的屏幕刷新频率是固定的，<code>CADisplayLink</code> 在正常情况下会在每次刷新结束都被调用，精确度相当高。<br><code>NSTimer</code> 的精确度就显得低了点，比如 <code>NSTimer</code> 的触发时间到的时候，Runloop 如果在忙于别的调用，触发时间就会推迟到下一个 Runloop 周期。更有甚者，在 OS X 10.9 以后为了尽量避免在 <code>NSTimer</code> 触发时间到了而去中断当前处理的任务，NSTimer新增了<code>tolerance</code> 属性，让用户可以设置可以容忍的触发的时间范围。  </p>
</blockquote>
<p>4、使用场合</p>
<blockquote>
<p>从原理上不难看出，<code>CADisplayLink</code> 使用场合相对专一，适合做界面的不停重绘，比如视频播放的时候需要不停地获取下一帧用于界面渲染。<br><code>NSTimer</code> 的使用范围要广泛的多，各种需要单次或者循环定时处理的任务都可以使用。</p>
</blockquote>
<p>请参考：</p>
<p><a href="http://blog.csdn.net/wzzvictory/article/details/22417181" target="_blank" rel="external">http://blog.csdn.net/wzzvictory/article/details/22417181</a>  </p>
<h2 id="1-如何画曲线"><a href="#1-如何画曲线" class="headerlink" title="1.如何画曲线"></a>1.如何画曲线</h2><p>效果展示：</p>
<p><img src="/images/animation_gooeytabbar/02.gif" alt="animation_gooeytabbar/02.gif">  </p>
<p>p0,p2 是普通点，p1 是控制点。 </p>
<p>代码实现：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">override func drawRect(rect: CGRect) &#123;</div><div class="line">  // Drawing code</div><div class="line">  let p0 = CGPoint(x: 50, y: 50) // 点 p0 </div><div class="line">  let p1 = CGPoint(x: 65, y: 25) // 点 p1</div><div class="line">  let p2 = CGPoint(x: 100, y: 50) // 点 p2</div><div class="line">  </div><div class="line">  let path = UIBezierPath() // 创建 贝塞尔曲线路径 对象</div><div class="line">  path.moveToPoint(p0) // 将画笔移至 点 p0</div><div class="line">  path.addQuadCurveToPoint(p2, controlPoint: p1) // 为 p2添加二维曲线控制点为p1</div><div class="line">  </div><div class="line">  let context = UIGraphicsGetCurrentContext() // 当前绘制上下文</div><div class="line">  CGContextAddPath(context, path.CGPath) // 将创建的贝塞尔曲线路径对象添加至上下文中</div><div class="line">  UIColor.redColor().set() // 设置绘制颜色</div><div class="line">  CGContextStrokePath(context) // 绘制</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="2-如何使用弹性动画"><a href="#2-如何使用弹性动画" class="headerlink" title="2.如何使用弹性动画"></a>2.如何使用弹性动画</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">弹性动画</div><div class="line">        </div><div class="line">- parameter duration:               动画时长</div><div class="line">- parameter delay:                  延迟时长</div><div class="line">- parameter usingSpringWithDamping: 阻尼系数</div><div class="line">- parameter initialSpringVelocity:  初始弹性速度</div><div class="line">- parameter options:                动画选项 如:EaseInOut</div><div class="line">- parameter animations:             动画 Block</div><div class="line">- parameter completion:             动画完成 Block</div><div class="line">*/</div><div class="line">@available(iOS 7.0, *)</div><div class="line">public class func animateWithDuration(</div><div class="line">duration: NSTimeInterval, </div><div class="line">delay: NSTimeInterval, </div><div class="line">usingSpringWithDamping dampingRatio: CGFloat, </div><div class="line">initialSpringVelocity velocity: CGFloat, </div><div class="line">options: UIViewAnimationOptions, </div><div class="line">animations: () -&gt; Void, </div><div class="line">completion: ((Bool) -&gt; Void)?</div><div class="line">)</div></pre></td></tr></table></figure>
<p>上面的注释已经写得很清楚，需要注意的是 <code>usingSpringWithDamping</code> 参数，即阻尼系数，数值范围 <code>0 &lt;= n &lt;= 1</code>,系数越大弹性越大。  </p>
<p>更多详细介绍，请参考：  </p>
<p><a href="https://www.renfei.org/blog/ios-8-spring-animation.html" target="_blank" rel="external">https://www.renfei.org/blog/ios-8-spring-animation.html</a>  </p>
<h2 id="3-粘性动画原理"><a href="#3-粘性动画原理" class="headerlink" title="3.粘性动画原理"></a>3.粘性动画原理</h2><p>效果展示：</p>
<p><img src="/images/animation_gooeytabbar/03.gif" alt="animation_gooeytabbar/03.gif">   </p>
<p>代码实现： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">override func drawRect(rect: CGRect) &#123;</div><div class="line">  // Drawing code</div><div class="line">  let viewWidth = self.frame.width // view 的宽度</div><div class="line">  let viewHeight = self.frame.height // view 的高度</div><div class="line"></div><div class="line">  UIColor.redColor().set()</div><div class="line">  let context = UIGraphicsGetCurrentContext()</div><div class="line">  CGContextMoveToPoint(context, 0, viewHeight) // 左下角点</div><div class="line">  CGContextAddLineToPoint(context, viewWidth, viewHeight) // 右下角点</div><div class="line">  CGContextAddLineToPoint(context, viewWidth, 120) // 右上角点</div><div class="line">  CGContextAddQuadCurveToPoint(context, viewWidth/2.0, 120 + CGFloat(progress), 0, 120) // 左上角 控制点</div><div class="line">  CGContextClosePath(context) //将开始点和结束点连接起来</div><div class="line">  CGContextFillPath(context) // 填充</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="4-源码分析"><a href="#4-源码分析" class="headerlink" title="4.源码分析"></a>4.源码分析</h2><p>详见<a href="http://pan.baidu.com/s/1qYUUKaw" target="_blank" rel="external">分享链接</a>里的源码注释。</p>
<h2 id="5-源码中的几个问题"><a href="#5-源码中的几个问题" class="headerlink" title="5.源码中的几个问题"></a>5.源码中的几个问题</h2><h4 id="内存引用问题"><a href="#内存引用问题" class="headerlink" title="内存引用问题"></a>内存引用问题</h4><p>源码 TabbarMenu.swift 中有这么一段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">private var animateButton : AnimatedButton? // 动画按钮</div><div class="line"></div><div class="line">//动画那个按钮 即那两条横线</div><div class="line">animateButton = AnimatedButton(frame: CGRect(x: 0, y: 200, width: 50, height: 30))</div><div class="line">self.view.addSubview(animateButton!)</div><div class="line">animateButton!.didTapped = &#123; (button) -&gt; () in</div><div class="line">  self.triggerAction() // 按钮点击触发方法</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里面存在着一个保留环的问题：  </p>
<ol>
<li>TabbarMenu 实例 <code>self</code> 引用了 <code>animationButton</code>。  </li>
<li><code>animationButton</code> 的 block <code>didTapped</code> 又引用了<br><code>self.triggerAction()</code>。</li>
</ol>
<p>如何解决这个问题？在 Objective-C 中我们使用 <code>__weak</code>,在 Swift 中呢？我们需要添加 <code>[unowned self]</code>。实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//动画那个按钮 即那两条横线</div><div class="line">animateButton = AnimatedButton(frame: CGRect(x: 0, y: 200, width: 50, height: 30))</div><div class="line">self.view.addSubview(animateButton!)</div><div class="line">animateButton!.didTapped = &#123; [unowned self](button) -&gt; () in</div><div class="line">  self.triggerAction() // 按钮点击触发方法</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>关于 Swift 保留环，如何处理的问题，请参考：  </p>
<p><a href="http://stackoverflow.com/questions/24042949/block-retain-cycles-in-swift" target="_blank" rel="external">Block retain cycles in Swift?</a>  </p>
<h4 id="私有方法问题"><a href="#私有方法问题" class="headerlink" title="私有方法问题"></a>私有方法问题</h4><p>源码 AnimatedButton.swift 中有这么一段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">self.addTarget(self, action: #selector(AnimatedButton.animate), forControlEvents: .TouchUpInside)  </div><div class="line"></div><div class="line">@objc private func animate() &#123;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>@objc</code> 是什么鬼？</p>
<p>如果去掉 <code>@objc</code>,在 Xcode 7.3 中会直接报错(Xcode 老版本 运行点击按钮会出现崩溃)：  </p>
<p><img src="/images/animation_gooeytabbar/04.png" alt="animation_gooeytabbar/04.png"></p>
<p><a href="http://stackoverflow.com/questions/25056278/swift-access-control-with-target-selectors" target="_blank" rel="external">经查证</a>，原因如下：</p>
<blockquote>
<p>Declarations marked private are not exposed to the Objective-C runtime if not otherwise annotated. IB outlets, IB actions, and Core Data managed properties remain exposed to Objective-C whatever their access level. If you need a private method or property to be callable from Objective-C (such as for an older API that uses a selector-based callback), add the @objc attribute to the declaration explicitly.</p>
</blockquote>
<p>大意为:</p>
<p>在 Swift 中,如果将方法或者属性标记为 <code>private</code>,将不会给 Objective-C Runtime 暴漏，如果想从 Objective-C（一些老的 API，像基于选择器的回调），必须明确添加 <code>@objc</code> 标识。</p>
<h4 id="修改高斯模糊视图-alpha-问题"><a href="#修改高斯模糊视图-alpha-问题" class="headerlink" title="修改高斯模糊视图 alpha 问题"></a>修改高斯模糊视图 alpha 问题</h4><p>在运行源码的过程中，我们看到控制台打印出如下警告：</p>
<blockquote>
<p>2016-03-27 10:29:28.879 GooeyTabbar[54798:1868007] <uivisualeffectview 0x7fcc9bd06fe0=""> is being asked to animate its opacity. This will cause the effect to appear broken until opacity returns to 1.</uivisualeffectview></p>
</blockquote>
<p>不应该修改 <code>UIVisualEffectView</code> 的 <code>opacity</code> 的属性。应做如下修改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let overlay = UIVisualEffectView()</div><div class="line">// Put it somewhere, give it a frame...</div><div class="line">UIView.animateWithDuration(0.5) &#123;</div><div class="line">    overlay.effect = UIBlurEffect(style: .Light)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>请参考：</p>
<p><a href="http://stackoverflow.com/questions/29307827/how-does-one-fade-a-uivisualeffectview-and-or-uiblureffect-in-and-out" target="_blank" rel="external">http://stackoverflow.com/questions/29307827/how-does-one-fade-a-uivisualeffectview-and-or-uiblureffect-in-and-out</a>  </p>
<h2 id="6-分享的心得体会"><a href="#6-分享的心得体会" class="headerlink" title="6.分享的心得体会"></a>6.分享的心得体会</h2><h4 id="0-如果一件事情你从来没做过，身边又没有合适的老师，怎么办-？"><a href="#0-如果一件事情你从来没做过，身边又没有合适的老师，怎么办-？" class="headerlink" title="0.如果一件事情你从来没做过，身边又没有合适的老师，怎么办 ？"></a>0.如果一件事情你从来没做过，身边又没有合适的老师，怎么办 ？</h4><p> <strong>从网上找相关专业最好的东西来模仿</strong>。</p>
<p> 我找的是苹果 WWDC Keynote 视频：  </p>
<p> <a href="https://developer.apple.com/videos/play/wwdc2015-106/" target="_blank" rel="external">What is New in Swift</a>    </p>
<h4 id="1-如何进行设计"><a href="#1-如何进行设计" class="headerlink" title="1.如何进行设计"></a>1.如何进行设计</h4><p>  现在才发现设计是如此重要，做程序猿也要文艺点。由于原先就意识到这个问题，读过《写给  大家看的设计书》这本书，如何对齐、如何重复、如何配色等等。这些对我启发很大。每个像素都值得深究。  </p>
<h4 id="2-如何配图"><a href="#2-如何配图" class="headerlink" title="2.如何配图"></a>2.如何配图</h4><p>   Keynote 中最重要的一点，就是好的配图。配图能激发听者的兴趣。因为原先写博客的原因，积累了一些有意思的配图。平常发现有意思的图，就应该收藏下来，说不定哪天就能派上用场。  </p>
<h4 id="3-一些新的发现"><a href="#3-一些新的发现" class="headerlink" title="3.一些新的发现"></a>3.一些新的发现</h4><p>   通过学习 Keynote，我找到了一些好的资料，比如许岑老师的教程以及如何使用 Keynote 做动效等。把每件小事做好，都是一件不简单的事情。  </p>
<h4 id="4-不足"><a href="#4-不足" class="headerlink" title="4.不足"></a>4.不足</h4><p>口才。终于明白，提前排练的重要性（连乔布斯也要在演讲前都要反复排练）。自己没有排练过，导致语次颠倒，逻辑稍有混乱。</p>
<h2 id="7-图片版"><a href="#7-图片版" class="headerlink" title="7.图片版"></a>7.图片版</h2><p><img src="/images/animation_gooeytabbar/1.jpeg" alt="images/1.jpeg"></p>
<p><img src="/images/animation_gooeytabbar/2.jpeg" alt="images/2.jpeg"></p>
<p><img src="/images/animation_gooeytabbar/3.jpeg" alt="images/3.jpeg"></p>
<p><img src="/images/animation_gooeytabbar/4.jpeg" alt="images/4.jpeg"></p>
<p><img src="/images/animation_gooeytabbar/5.jpeg" alt="images/5.jpeg"></p>
<p><img src="/images/animation_gooeytabbar/6.jpeg" alt="images/6.jpeg"></p>
<p><img src="/images/animation_gooeytabbar/7.jpeg" alt="images/7.jpeg"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;周四(2016-03-24)下午在公司做了一次技术分享，现整理成博客的形式。  &lt;/p&gt;
&lt;p&gt;分享的内容是一款动画，动画源码下载地址、效果及 Keynote 下载地址如下：&lt;/p&gt;
&lt;p&gt;源码下载地址：  &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.c
    
    </summary>
    
      <category term="iOS" scheme="http://iYiming.me/categories/iOS/"/>
    
    
  </entry>
  
</feed>
